{
  "address": "0x19fFe0Ba818F4cd6fFE4AefF62ef306B795758e2",
  "abi": [
    {
      "inputs": [],
      "name": "MATH_ADDITION_OVERFLOW",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "MATH_DIVISION_BY_ZERO",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "MATH_MULTIPLICATION_OVERFLOW",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "borrower",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint128",
          "name": "rate",
          "type": "uint128"
        },
        {
          "indexed": false,
          "internalType": "uint128",
          "name": "remainingLiquidityRewards",
          "type": "uint128"
        },
        {
          "indexed": false,
          "internalType": "uint128",
          "name": "addedAccruedFees",
          "type": "uint128"
        }
      ],
      "name": "CollectFeesForTick",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "ownerAddress",
          "type": "address"
        }
      ],
      "name": "PoolActivated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "borrower",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint128",
          "name": "rate",
          "type": "uint128"
        },
        {
          "indexed": false,
          "internalType": "uint128",
          "name": "adjustedRemainingAmountReduction",
          "type": "uint128"
        },
        {
          "indexed": false,
          "internalType": "uint128",
          "name": "loanedAmount",
          "type": "uint128"
        },
        {
          "indexed": false,
          "internalType": "uint128",
          "name": "atlendisLiquidityRatio",
          "type": "uint128"
        },
        {
          "indexed": false,
          "internalType": "uint128",
          "name": "unborrowedRatio",
          "type": "uint128"
        }
      ],
      "name": "TickBorrow",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "borrower",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint128",
          "name": "rate",
          "type": "uint128"
        },
        {
          "indexed": false,
          "internalType": "uint128",
          "name": "atlendisLiquidityRatio",
          "type": "uint128"
        }
      ],
      "name": "TickInitialized",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "borrower",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint128",
          "name": "rate",
          "type": "uint128"
        },
        {
          "indexed": false,
          "internalType": "uint128",
          "name": "adjustedPendingDeposit",
          "type": "uint128"
        }
      ],
      "name": "TickLoanDeposit",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "borrower",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint128",
          "name": "rate",
          "type": "uint128"
        },
        {
          "indexed": false,
          "internalType": "uint128",
          "name": "adjustedPendingDeposit",
          "type": "uint128"
        },
        {
          "indexed": false,
          "internalType": "uint128",
          "name": "atlendisLiquidityRatio",
          "type": "uint128"
        }
      ],
      "name": "TickNoLoanDeposit",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "borrower",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint128",
          "name": "rate",
          "type": "uint128"
        },
        {
          "indexed": false,
          "internalType": "uint128",
          "name": "adjustedPendingAmount",
          "type": "uint128"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "poolBondIssuanceIndexIncremented",
          "type": "bool"
        }
      ],
      "name": "TickPendingDeposit",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "borrower",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint128",
          "name": "rate",
          "type": "uint128"
        },
        {
          "indexed": false,
          "internalType": "uint128",
          "name": "newAdjustedRemainingAmount",
          "type": "uint128"
        },
        {
          "indexed": false,
          "internalType": "uint128",
          "name": "atlendisLiquidityRatio",
          "type": "uint128"
        }
      ],
      "name": "TickRepay",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "borrower",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint128",
          "name": "rate",
          "type": "uint128"
        },
        {
          "indexed": false,
          "internalType": "uint128",
          "name": "adjustedAmountToWithdraw",
          "type": "uint128"
        }
      ],
      "name": "TickWithdrawPending",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "borrower",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint128",
          "name": "rate",
          "type": "uint128"
        },
        {
          "indexed": false,
          "internalType": "uint128",
          "name": "adjustedAmountToWithdraw",
          "type": "uint128"
        },
        {
          "indexed": false,
          "internalType": "uint128",
          "name": "atlendisLiquidityRatio",
          "type": "uint128"
        },
        {
          "indexed": false,
          "internalType": "uint128",
          "name": "accruedFeesToWithdraw",
          "type": "uint128"
        }
      ],
      "name": "TickWithdrawRemaining",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "borrower",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint128",
          "name": "addedLiquidityRewards",
          "type": "uint128"
        }
      ],
      "name": "TopUpLiquidityRewards",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "RAY",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "SECONDS_PER_YEAR",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "WAD",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint128",
          "name": "rate",
          "type": "uint128"
        },
        {
          "internalType": "uint128",
          "name": "loanDuration",
          "type": "uint128"
        }
      ],
      "name": "getTickBondPrice",
      "outputs": [
        {
          "internalType": "uint128",
          "name": "price",
          "type": "uint128"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    }
  ],
  "transactionHash": "0x9e9ed9604269f8c163163e6b9d373e9722e2dbc95c06ebbff365d1b74f45997f",
  "receipt": {
    "to": null,
    "from": "0xfd94B585517d532BC4B80E35bC26383E7834f8b9",
    "contractAddress": "0x19fFe0Ba818F4cd6fFE4AefF62ef306B795758e2",
    "transactionIndex": 66,
    "gasUsed": "2621978",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xea55c19b2cac385aafa2b85abe0ed23bfbcdaad8e32e204d2b293ce3f065e013",
    "transactionHash": "0x9e9ed9604269f8c163163e6b9d373e9722e2dbc95c06ebbff365d1b74f45997f",
    "logs": [],
    "blockNumber": 7715714,
    "cumulativeGasUsed": "16987415",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 2,
  "solcInputHash": "096043261f950c0fc713eb6537ea2194",
  "metadata": "{\"compiler\":{\"version\":\"0.8.13+commit.abaa5c0e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"MATH_ADDITION_OVERFLOW\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MATH_DIVISION_BY_ZERO\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MATH_MULTIPLICATION_OVERFLOW\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"rate\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"remainingLiquidityRewards\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"addedAccruedFees\",\"type\":\"uint128\"}],\"name\":\"CollectFeesForTick\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"ownerAddress\",\"type\":\"address\"}],\"name\":\"PoolActivated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"rate\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"adjustedRemainingAmountReduction\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"loanedAmount\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"atlendisLiquidityRatio\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"unborrowedRatio\",\"type\":\"uint128\"}],\"name\":\"TickBorrow\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"rate\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"atlendisLiquidityRatio\",\"type\":\"uint128\"}],\"name\":\"TickInitialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"rate\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"adjustedPendingDeposit\",\"type\":\"uint128\"}],\"name\":\"TickLoanDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"rate\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"adjustedPendingDeposit\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"atlendisLiquidityRatio\",\"type\":\"uint128\"}],\"name\":\"TickNoLoanDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"rate\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"adjustedPendingAmount\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"poolBondIssuanceIndexIncremented\",\"type\":\"bool\"}],\"name\":\"TickPendingDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"rate\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"newAdjustedRemainingAmount\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"atlendisLiquidityRatio\",\"type\":\"uint128\"}],\"name\":\"TickRepay\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"rate\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"adjustedAmountToWithdraw\",\"type\":\"uint128\"}],\"name\":\"TickWithdrawPending\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"rate\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"adjustedAmountToWithdraw\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"atlendisLiquidityRatio\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"accruedFeesToWithdraw\",\"type\":\"uint128\"}],\"name\":\"TickWithdrawRemaining\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"addedLiquidityRewards\",\"type\":\"uint128\"}],\"name\":\"TopUpLiquidityRewards\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"RAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SECONDS_PER_YEAR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WAD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"rate\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"loanDuration\",\"type\":\"uint128\"}],\"name\":\"getTickBondPrice\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"price\",\"type\":\"uint128\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"_getRepaymentAmount(Types.Pool storage,uint128)\":{\"params\":{\"loanAmount\":\"The total amount of the loan\"},\"returns\":{\"repaymentAmount\":\"The total amount to be repaid *\"}},\"addBondsToTick(Types.Pool storage,uint128,uint128,uint128)\":{\"details\":\"Makes all the state changes necessary to add bonds to a tick Updates tick data and conversion data*\"},\"calculateBondIssuanceForTick(Types.Pool storage,uint128,uint128)\":{\"details\":\"Computes the quantity of bonds that would be purchased.*\"},\"computeAmountRepartitionForTick(Types.Pool storage,uint128,uint128,uint128)\":{\"details\":\"Computes how the position is split between deposit and bonds*\"},\"depositToTick(Types.Pool storage,uint128,uint128)\":{\"details\":\"Deposit to a target tick Updates tick data*\"},\"distributeLiquidityRewards(Types.Pool storage)\":{\"details\":\"Distributes remaining liquidity rewards reserve to lenders Called in case of pool default*\"},\"getBondsIssuanceParametersForTick(Types.Pool storage,uint128,uint128)\":{\"details\":\"Computes the quantity of bonds purchased, and the equivalent adjusted deposit amount used for the issuance*\"},\"getRepayValue(Types.Pool storage,bool)\":{\"details\":\"The return value includes only notional and accrued interest, it does not include any fees due for repay by the borrrower*\"},\"getTickBondPrice(uint128,uint128)\":{\"params\":{\"loanDuration\":\"The duration of the loan\",\"rate\":\"The rate of the loan\"},\"returns\":{\"price\":\"The price per bond*\"}},\"peekAccruedFeesShare(Types.Pool storage,uint128,uint128,uint128)\":{\"details\":\"Get share of accumulated fees from estimated current tick state*\"},\"repayForTick(Types.Pool storage,uint128,uint128)\":{\"details\":\"Updates tick data after a repayment*\"},\"topUpLiquidityRewards(Types.Pool storage,uint128)\":{\"details\":\"Top up liquidity rewards for later distribution*\"},\"withdrawDepositedAmountForTick(Types.Pool storage,uint128,uint128,uint128)\":{\"details\":\"Updates tick data after a withdrawal consisting of only amount deposited to yield provider*\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"_getRepaymentAmount(Types.Pool storage,uint128)\":{\"notice\":\"Get repaymentAmount for a given loanAmount\"},\"getTickBondPrice(uint128,uint128)\":{\"notice\":\"Calculates the proce per bond accordingly to rate and loanDuration \"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"src/lib/PoolLogic.sol\":\"PoolLogic\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":100},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\",\"keccak256\":\"0x4e733d3164f73f461eaf9d8087a7ad1ea180bdc8ba0d3d61b0e1ae16d8e63dff\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20PermitUpgradeable {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0xcc70d8e2281fb3ff69e8ab242500f10142cd0a7fa8dd9e45882be270d4d09024\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20Upgradeable.sol\\\";\\nimport \\\"../extensions/draft-IERC20PermitUpgradeable.sol\\\";\\nimport \\\"../../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20Upgradeable {\\n    using AddressUpgradeable for address;\\n\\n    function safeTransfer(\\n        IERC20Upgradeable token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20Upgradeable token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20Upgradeable token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20Upgradeable token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20Upgradeable token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    function safePermit(\\n        IERC20PermitUpgradeable token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf42efac0d704b136c4d85e970562d4dbc1160d726ee93b5133122eb14fe368df\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x611aa3f23e59cfdd1863c536776407b3e33d695152a266fa7cfb34440a29a8a3\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = allowance(owner, spender);\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `from` to `to`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n        }\\n        _balances[to] += amount;\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n        }\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\",\"keccak256\":\"0x24b04b8aacaaf1a4a0719117b29c9c3647b1f479c5ac2a60f5ff1bb6d839c238\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\",\"keccak256\":\"0x9750c6b834f7b43000631af5cc30001c5f547b3ceb3635488f140f60e897ea6b\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x8de418a5503946cabe331f35fe242d3201a73f67f77aaeb7110acb1f30423aca\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0xf41ca991f30855bf80ffd11e9347856a517b977f0a6c2d52e6421a99b7840329\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/draft-IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x032807210d1d7d218963d7355d62e021a84bf1b3339f4f50be2f63b53cccaf29\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xd6153ce99bcdcce22b124f755e72553295be6abcd63804cfdffceb188b8bef10\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0xe2e337e6dde9ef6b680e07338c493ebea1b5fd09b43424112868e9cc1706bca7\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. It the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`.\\n        // We also know that `k`, the position of the most significant bit, is such that `msb(a) = 2**k`.\\n        // This gives `2**k < a <= 2**(k+1)` \\u2192 `2**(k/2) <= sqrt(a) < 2 ** (k/2+1)`.\\n        // Using an algorithm similar to the msb conmputation, we are able to compute `result = 2**(k/2)` which is a\\n        // good first aproximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1;\\n        uint256 x = a;\\n        if (x >> 128 > 0) {\\n            x >>= 128;\\n            result <<= 64;\\n        }\\n        if (x >> 64 > 0) {\\n            x >>= 64;\\n            result <<= 32;\\n        }\\n        if (x >> 32 > 0) {\\n            x >>= 32;\\n            result <<= 16;\\n        }\\n        if (x >> 16 > 0) {\\n            x >>= 16;\\n            result <<= 8;\\n        }\\n        if (x >> 8 > 0) {\\n            x >>= 8;\\n            result <<= 4;\\n        }\\n        if (x >> 4 > 0) {\\n            x >>= 4;\\n            result <<= 2;\\n        }\\n        if (x >> 2 > 0) {\\n            result <<= 1;\\n        }\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = sqrt(a);\\n        if (rounding == Rounding.Up && result * result < a) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n}\\n\",\"keccak256\":\"0xd15c3e400531f00203839159b2b8e7209c5158b35618f570c695b7e47f12e9f0\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x0f633a0223d9a1dcccfcf38a64c9de0874dfcbfac0c6941ccf074d63a2ce0e1e\",\"license\":\"MIT\"},\"hardhat/console.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.4.22 <0.9.0;\\n\\nlibrary console {\\n\\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\\n\\n\\tfunction _sendLogPayload(bytes memory payload) private view {\\n\\t\\tuint256 payloadLength = payload.length;\\n\\t\\taddress consoleAddress = CONSOLE_ADDRESS;\\n\\t\\tassembly {\\n\\t\\t\\tlet payloadStart := add(payload, 32)\\n\\t\\t\\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\\n\\t\\t}\\n\\t}\\n\\n\\tfunction log() internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n\\t}\\n\\n\\tfunction logInt(int256 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(int256)\\\", p0));\\n\\t}\\n\\n\\tfunction logUint(uint256 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n\\t}\\n\\n\\tfunction logString(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction logBool(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction logAddress(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes(bytes memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes1(bytes1 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes2(bytes2 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes3(bytes3 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes4(bytes4 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes5(bytes5 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes6(bytes6 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes7(bytes7 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes8(bytes8 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes9(bytes9 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes10(bytes10 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes11(bytes11 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes12(bytes12 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes13(bytes13 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes14(bytes14 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes15(bytes15 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes16(bytes16 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes17(bytes17 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes18(bytes18 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes19(bytes19 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes20(bytes20 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes21(bytes21 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes22(bytes22 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes23(bytes23 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes24(bytes24 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes25(bytes25 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes26(bytes26 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes27(bytes27 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes28(bytes28 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes29(bytes29 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes30(bytes30 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes31(bytes31 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes32(bytes32 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint256 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n\\t}\\n\\n\\tfunction log(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction log(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction log(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n}\\n\",\"keccak256\":\"0x60b0215121bf25612a6739fb2f1ec35f31ee82e4a8216c032c8243d904ab3aa9\",\"license\":\"MIT\"},\"src/extensions/BaseStrategy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0 <=0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"./interfaces/VaultApi.sol\\\";\\nimport \\\"./interfaces/StrategyApi.sol\\\";\\n\\n/*\\n * BaseStrategy implements all of the required functionality to interoperate closely\\n * with the core protocol. This contract should be inherited and the abstract methods\\n * implemented to adapt the strategy to the particular needs it has to create a return.\\n */\\n\\nabstract contract BaseStrategy is StrategyAPI {\\n\\n    // Version of this contract's StrategyAPI (must match Vault)\\n    function apiVersion() override public pure returns (string memory) {\\n        return \\\"0.1.3\\\";\\n    }\\n\\n    address override public vault;\\n    address public strategist;\\n    address override public keeper;\\n\\n    address override public want;\\n\\n    // So indexers can keep track of this\\n    event Harvested(uint256 profit);\\n\\n    // The minimum number of blocks between harvest calls\\n    // NOTE: Override this value with your own, or set dynamically below\\n    uint256 public minReportDelay = 6300; // ~ once a day\\n\\n    // The minimum multiple that `callCost` must be above the credit/profit to be \\\"justifiable\\\"\\n    // NOTE: Override this value with your own, or set dynamically below\\n    uint256 public profitFactor = 100;\\n\\n    // Use this to adjust the threshold at which running a debt causes a harvest trigger\\n    uint256 public debtThreshold = 0;\\n\\n    // Adjust this using `setReserve(...)` to keep some of the position in reserve in the strategy,\\n    // to accomodate larger variations needed to sustain the strategy's core positon(s)\\n    uint256 private reserve = 0;\\n    \\n    /*\\n     * Provide an accurate estimate for the total amount of assets (principle + return)\\n     * that this strategy is currently managing, denominated in terms of `want` tokens.\\n     * This total should be \\\"realizable\\\" e.g. the total value that could *actually* be\\n     * obtained from this strategy if it were to divest it's entire position based on\\n     * current on-chain conditions.\\n     *\\n     * NOTE: care must be taken in using this function, since it relies on external\\n     *       systems, which could be manipulated by the attacker to give an inflated\\n     *       (or reduced) value produced by this function, based on current on-chain\\n     *       conditions (e.g. this function is possible to influence through flashloan\\n     *       attacks, oracle manipulations, or other DeFi attack mechanisms).\\n     *\\n     * NOTE: It is up to governance to use this function to correctly order this strategy\\n     *       relative to its peers in the withdrawal queue to minimize losses for the Vault\\n     *       based on sudden withdrawals. This value should be higher than the total debt of\\n     *       the strategy and higher than it's expected value to be \\\"safe\\\".\\n     */\\n    function estimatedTotalAssets() override public view virtual returns (uint256);\\n\\n    function getReserve() internal view returns (uint256) {\\n        return reserve;\\n    }\\n\\n    function setReserve(uint256 _reserve) internal {\\n        if (_reserve != reserve) reserve = _reserve;\\n    }\\n\\n    bool public emergencyExit;\\n\\n    constructor(address _vault) {\\n        vault = _vault;\\n        want = VaultAPI(vault).token();\\n        IERC20(want).approve(_vault, type(uint256).max); // Give Vault unlimited access (might save gas)\\n        strategist = msg.sender;\\n        keeper = msg.sender;\\n    }\\n\\n    function setStrategist(address _strategist) external {\\n        require(\\n            msg.sender == strategist || msg.sender == governance(),\\n            \\\"!authorized\\\"\\n        );\\n        strategist = _strategist;\\n    }\\n\\n    function setKeeper(address _keeper) external {\\n        require(\\n            msg.sender == strategist || msg.sender == governance(),\\n            \\\"!authorized\\\"\\n        );\\n        keeper = _keeper;\\n    }\\n\\n    function setMinReportDelay(uint256 _delay) external {\\n        require(\\n            msg.sender == strategist || msg.sender == governance(),\\n            \\\"!authorized\\\"\\n        );\\n        minReportDelay = _delay;\\n    }\\n\\n    function setProfitFactor(uint256 _profitFactor) external {\\n        require(\\n            msg.sender == strategist || msg.sender == governance(),\\n            \\\"!authorized\\\"\\n        );\\n        profitFactor = _profitFactor;\\n    }\\n\\n    function setDebtThreshold(uint256 _debtThreshold) external {\\n        require(\\n            msg.sender == strategist || msg.sender == governance(),\\n            \\\"!authorized\\\"\\n        );\\n        debtThreshold = _debtThreshold;\\n    }\\n\\n    /*\\n     * Resolve governance address from Vault contract, used to make\\n     * assertions on protected functions in the Strategy\\n     */\\n    function governance() internal view returns (address) {\\n        return VaultAPI(vault).governance();\\n    }\\n\\n    /*\\n     * Perform any strategy unwinding or other calls necessary to capture\\n     * the \\\"free return\\\" this strategy has generated since the last time it's\\n     * core position(s) were adusted. Examples include unwrapping extra rewards.\\n     * This call is only used during \\\"normal operation\\\" of a Strategy, and should\\n     * be optimized to minimize losses as much as possible. It is okay to report\\n     * \\\"no returns\\\", however this will affect the credit limit extended to the\\n     * strategy and reduce it's overall position if lower than expected returns\\n     * are sustained for long periods of time.\\n     */\\n    function prepareReturn(uint256 _debtOutstanding)\\n        internal\\n        virtual\\n        returns (uint256 _profit);\\n\\n    /*\\n     * Perform any adjustments to the core position(s) of this strategy given\\n     * what change the Vault made in the \\\"investable capital\\\" available to the\\n     * strategy. Note that all \\\"free capital\\\" in the strategy after the report\\n     * was made is available for reinvestment. Also note that this number could\\n     * be 0, and you should handle that scenario accordingly.\\n     */\\n    function adjustPosition(uint256 _debtOutstanding) internal virtual;\\n\\n    /*\\n     * Make as much capital as possible \\\"free\\\" for the Vault to take. Some slippage\\n     * is allowed, since when this method is called the strategist is no longer receiving\\n     * their performance fee. The goal is for the strategy to divest as quickly as possible\\n     * while not suffering exorbitant losses. This function is used during emergency exit\\n     * instead of `prepareReturn()`\\n     */\\n    function exitPosition() internal virtual;\\n\\n    /*\\n     * Vault calls this function after shares are created during `Vault.report()`.\\n     * You can customize this function to any share distribution mechanism you want.\\n     */\\n    function distributeRewards(uint256 _shares) external virtual {\\n        // Send 100% of newly-minted shares to the strategist.\\n        VaultAPI(vault).transfer(strategist, _shares);\\n    }\\n\\n    /*\\n     * Provide a signal to the keeper that `tend()` should be called. The keeper will provide\\n     * the estimated gas cost that they would pay to call `tend()`, and this function should\\n     * use that estimate to make a determination if calling it is \\\"worth it\\\" for the keeper.\\n     * This is not the only consideration into issuing this trigger, for example if the position\\n     * would be negatively affected if `tend()` is not called shortly, then this can return `true`\\n     * even if the keeper might be \\\"at a loss\\\" (keepers are always reimbursed by Yearn)\\n     *\\n     * NOTE: `callCost` must be priced in terms of `want`\\n     *\\n     * NOTE: this call and `harvestTrigger` should never return `true` at the same time.\\n     */\\n    function tendTrigger(uint256 callCost) override public view virtual returns (bool) {\\n        // We usually don't need tend, but if there are positions that need active maintainence,\\n        // overriding this function is how you would signal for that\\n        return false;\\n    }\\n\\n    function tend() override external {\\n        if (keeper != address(0)) {\\n            require(\\n                msg.sender == keeper ||\\n                    msg.sender == strategist ||\\n                    msg.sender == governance(),\\n                \\\"!authorized\\\"\\n            );\\n        }\\n\\n        // Don't take profits with this call, but adjust for better gains\\n        adjustPosition(VaultAPI(vault).debtOutstanding());\\n    }\\n\\n    /*\\n     * Provide a signal to the keeper that `harvest()` should be called. The keeper will provide\\n     * the estimated gas cost that they would pay to call `harvest()`, and this function should\\n     * use that estimate to make a determination if calling it is \\\"worth it\\\" for the keeper.\\n     * This is not the only consideration into issuing this trigger, for example if the position\\n     * would be negatively affected if `harvest()` is not called shortly, then this can return `true`\\n     * even if the keeper might be \\\"at a loss\\\" (keepers are always reimbursed by Yearn)\\n     *\\n     * NOTE: `callCost` must be priced in terms of `want`\\n     *\\n     * NOTE: this call and `tendTrigger` should never return `true` at the same time.\\n     */\\n    function harvestTrigger(uint256 callCost)\\n        override\\n        public\\n        view\\n        virtual\\n        returns (bool)\\n    {\\n        StrategyParams memory params = VaultAPI(vault).strategies(address(this));\\n\\n        // Should not trigger if strategy is not activated\\n        if (params.activation == 0) return false;\\n\\n        // Should trigger if hadn't been called in a while\\n        if (block.number - params.lastReport >= minReportDelay) return true;\\n\\n        // If some amount is owed, pay it back\\n        // NOTE: Since debt is adjusted in step-wise fashion, it is appropiate to always trigger here,\\n        //       because the resulting change should be large (might not always be the case)\\n        uint256 outstanding = VaultAPI(vault).debtOutstanding();\\n        if (outstanding > 0) return true;\\n\\n        // Check for profits and losses\\n        uint256 total = estimatedTotalAssets();\\n        // Trigger if we have a loss to report\\n        if (total + debtThreshold < params.totalDebt) return true;\\n\\n        uint256 profit = 0;\\n        if (total > params.totalDebt) profit = total - params.totalDebt; // We've earned a profit!\\n\\n        // Otherwise, only trigger if it \\\"makes sense\\\" economically (gas cost is <N% of value moved)\\n        uint256 credit = VaultAPI(vault).creditAvailable();\\n        return (profitFactor * callCost < credit + profit);\\n    }\\n\\n    function harvest() override external {\\n        if (keeper != address(0)) {\\n            require(\\n                msg.sender == keeper ||\\n                    msg.sender == strategist ||\\n                    msg.sender == governance(),\\n                \\\"!authorized\\\"\\n            );\\n        }\\n\\n        uint256 profit = 0;\\n        if (emergencyExit) {\\n            exitPosition(); // Free up as much capital as possible\\n            // NOTE: Don't take performance fee in this scenario\\n        } else {\\n            profit = prepareReturn(VaultAPI(vault).debtOutstanding()); // Free up returns for Vault to pull\\n        }\\n\\n        if (reserve > IERC20(want).balanceOf(address(this)))\\n            reserve = IERC20(want).balanceOf(address(this));\\n\\n        // Allow Vault to take up to the \\\"harvested\\\" balance of this contract, which is\\n        // the amount it has earned since the last time it reported to the Vault\\n        uint256 outstanding = VaultAPI(vault).report(\\n            IERC20(want).balanceOf(address(this)) - reserve,\\n            0, 0\\n        );\\n\\n        // Check if free returns are left, and re-invest them\\n        adjustPosition(outstanding);\\n\\n        emit Harvested(profit);\\n    }\\n\\n    /*\\n     * Liquidate as many assets as possible to `want`, irregardless of slippage,\\n     * up to `_amountNeeded`. Any excess should be re-invested here as well.\\n     */\\n    function liquidatePosition(uint256 _amountNeeded)\\n        internal\\n        virtual\\n        returns (uint256 _amountFreed);\\n\\n    function withdraw(uint256 _amountNeeded) external {\\n        require(msg.sender == address(vault), \\\"!vault\\\");\\n        // Liquidate as much as possible to `want`, up to `_amount`\\n        uint256 amountFreed = liquidatePosition(_amountNeeded);\\n        // Send it directly back (NOTE: Using `msg.sender` saves some gas here)\\n        IERC20(want).transfer(msg.sender, amountFreed);\\n        // Adjust reserve to what we have after the freed amount is sent to the Vault\\n        reserve = IERC20(want).balanceOf(address(this));\\n    }\\n\\n    /*\\n     * Do anything necesseary to prepare this strategy for migration, such\\n     * as transfering any reserve or LP tokens, CDPs, or other tokens or stores of value.\\n     */\\n    function prepareMigration(address _newStrategy) internal virtual;\\n\\n    function migrate(address _newStrategy) external {\\n        require(msg.sender == address(vault) || msg.sender == governance());\\n        require(BaseStrategy(_newStrategy).vault() == vault);\\n        prepareMigration(_newStrategy);\\n        IERC20(want).transfer(_newStrategy, IERC20(want).balanceOf(address(this)));\\n    }\\n\\n    function setEmergencyExit() external {\\n        require(\\n            msg.sender == strategist || msg.sender == governance(),\\n            \\\"!authorized\\\"\\n        );\\n        emergencyExit = true;\\n        exitPosition();\\n        VaultAPI(vault).revokeStrategy();\\n        if (reserve > IERC20(want).balanceOf(address(this)))\\n            reserve = IERC20(want).balanceOf(address(this));\\n    }\\n\\n    // Override this to add all tokens/tokenized positions this contract manages\\n    // on a *persistant* basis (e.g. not just for swapping back to want ephemerally)\\n    // NOTE: Do *not* include `want`, already included in `sweep` below\\n    //\\n    // Example:\\n    //\\n    //    function protectedTokens() internal override view returns (address[] memory) {\\n    //      address[] memory protected = new address[](3);\\n    //      protected[0] = tokenA;\\n    //      protected[1] = tokenB;\\n    //      protected[2] = tokenC;\\n    //      return protected;\\n    //    }\\n    function protectedTokens() internal view virtual returns (address[] memory);\\n\\n    function sweep(address _token) external {\\n        require(msg.sender == governance(), \\\"!authorized\\\");\\n        require(_token != address(want), \\\"!want\\\");\\n\\n        address[] memory _protectedTokens = protectedTokens();\\n        for (uint256 i; i < _protectedTokens.length; i++)\\n            require(_token != _protectedTokens[i], \\\"!protected\\\");\\n\\n        IERC20(_token).transfer(\\n            governance(),\\n            IERC20(_token).balanceOf(address(this))\\n        );\\n    }\\n}\",\"keccak256\":\"0x70ed04e40035bada72ca1a28d4dfc2b9eb7158684f072141fba2dca4b6893fba\",\"license\":\"MIT\"},\"src/extensions/BaseWraper.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity >=0.8.0 <=0.8.13;\\npragma experimental ABIEncoderV2;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {SafeERC20} from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport {Math} from \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport {SafeMath} from \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\nimport \\\"hardhat/console.sol\\\";\\n\\nimport {VaultAPI} from \\\"./BaseStrategy.sol\\\";\\n\\ninterface RegistryAPI {\\n  function governance() external view returns (address);\\n\\n  function latestVault(address token) external view returns (address);\\n\\n  function numVaults(address token) external view returns (uint256);\\n\\n  function vaults(address token, uint256 deploymentId) external view returns (address);\\n}\\n\\n/**\\n * @title Yearn Base Wrapper\\n * @author yearn.finance\\n * @notice\\n *  BaseWrapper implements all of the required functionality to interoperate\\n *  closely with the Vault contract. This contract should be inherited and the\\n *  abstract methods implemented to adapt the Wrapper.\\n *  A good starting point to build a wrapper is https://github.com/yearn/brownie-wrapper-mix\\n *\\n */\\nabstract contract BaseWrapper {\\n  using Math for uint256;\\n  using SafeMath for uint256;\\n  using SafeERC20 for IERC20;\\n\\n  IERC20 public token;\\n\\n  // Reduce number of external calls (SLOADs stay the same)\\n  VaultAPI[] private _cachedVaults;\\n\\n  RegistryAPI public registry;\\n\\n  // ERC20 Unlimited Approvals (short-circuits VaultAPI.transferFrom)\\n  uint256 constant UNLIMITED_APPROVAL = type(uint256).max;\\n  // Sentinal values used to save gas on deposit/withdraw/migrate\\n  // NOTE: DEPOSIT_EVERYTHING == WITHDRAW_EVERYTHING == MIGRATE_EVERYTHING\\n  uint256 constant DEPOSIT_EVERYTHING = type(uint256).max;\\n  uint256 constant WITHDRAW_EVERYTHING = type(uint256).max;\\n  uint256 constant MIGRATE_EVERYTHING = type(uint256).max;\\n  // VaultsAPI.depositLimit is unlimited\\n  uint256 constant UNCAPPED_DEPOSITS = type(uint256).max;\\n\\n  constructor(address _token, address _registry) {\\n    // Recommended to use a token with a `Registry.latestVault(_token) != address(0)`\\n    token = IERC20(_token);\\n    // Recommended to use `v2.registry.ychad.eth`\\n    registry = RegistryAPI(_registry);\\n  }\\n\\n  /**\\n   * @notice\\n   *  Used to update the yearn registry.\\n   * @param _registry The new _registry address.\\n   */\\n  function setRegistry(address _registry) external {\\n    require(msg.sender == registry.governance());\\n    // In case you want to override the registry instead of re-deploying\\n    registry = RegistryAPI(_registry);\\n    // Make sure there's no change in governance\\n    // NOTE: Also avoid bricking the wrapper from setting a bad registry\\n    require(msg.sender == registry.governance());\\n  }\\n\\n  /**\\n   * @notice\\n   *  Used to get the most revent vault for the token using the registry.\\n   * @return An instance of a VaultAPI\\n   */\\n  function bestVault() public view virtual returns (VaultAPI) {\\n    return VaultAPI(registry.latestVault(address(token)));\\n  }\\n\\n  /**\\n   * @notice\\n   *  Used to get all vaults from the registery for the token\\n   * @return An array containing instances of VaultAPI\\n   */\\n  function allVaults() public view virtual returns (VaultAPI[] memory) {\\n    uint256 cache_length = _cachedVaults.length;\\n    uint256 num_vaults = registry.numVaults(address(token));\\n\\n    // Use cached\\n    if (cache_length == num_vaults) {\\n      return _cachedVaults;\\n    }\\n\\n    VaultAPI[] memory vaults = new VaultAPI[](num_vaults);\\n\\n    for (uint256 vault_id = 0; vault_id < cache_length; vault_id++) {\\n      vaults[vault_id] = _cachedVaults[vault_id];\\n    }\\n\\n    for (uint256 vault_id = cache_length; vault_id < num_vaults; vault_id++) {\\n      vaults[vault_id] = VaultAPI(registry.vaults(address(token), vault_id));\\n    }\\n\\n    return vaults;\\n  }\\n\\n  function _updateVaultCache(VaultAPI[] memory vaults) internal {\\n    // NOTE: even though `registry` is update-able by Yearn, the intended behavior\\n    //       is that any future upgrades to the registry will replay the version\\n    //       history so that this cached value does not get out of date.\\n    if (vaults.length > _cachedVaults.length) {\\n      _cachedVaults = vaults;\\n    }\\n  }\\n\\n  /**\\n   * @notice\\n   *  Used to get the balance of an account accross all the vaults for a token.\\n   *  @dev will be used to get the wrapper balance using totalVaultBalance(address(this)).\\n   *  @param account The address of the account.\\n   *  @return balance of token for the account accross all the vaults.\\n   */\\n  function totalVaultBalance(address account) public view returns (uint256 balance) {\\n    VaultAPI[] memory vaults = allVaults();\\n\\n    for (uint256 id = 0; id < vaults.length; id++) {\\n      uint256 individualBalance = vaults[id].balanceOf(account).mul(vaults[id].pricePerShare());\\n      balance = balance.add(\\n        vaults[id].balanceOf(account).mul(vaults[id].pricePerShare()).div(10**uint256(vaults[id].decimals()))\\n      );\\n    }\\n  }\\n\\n  /**\\n   * @notice\\n   *  Used to get the TVL on the underlying vaults.\\n   *  @return assets the sum of all the assets managed by the underlying vaults.\\n   */\\n  function totalAssets() public view returns (uint256 assets) {\\n    VaultAPI[] memory vaults = allVaults();\\n\\n    for (uint256 id = 0; id < vaults.length; id++) {\\n      assets = assets.add(vaults[id].totalAssets());\\n    }\\n  }\\n\\n  function _deposit(\\n    address depositor,\\n    address receiver,\\n    uint256 amount, // if `MAX_UINT256`, just deposit everything\\n    bool pullFunds // If true, funds need to be pulled from `depositor` via `transferFrom`\\n  ) internal returns (uint256 deposited) {\\n    VaultAPI _bestVault = bestVault();\\n\\n    if (pullFunds) {\\n      if (amount != DEPOSIT_EVERYTHING) {\\n        token.safeTransferFrom(depositor, address(this), amount);\\n      } else {\\n        token.safeTransferFrom(depositor, address(this), token.balanceOf(depositor));\\n      }\\n    }\\n\\n    if (token.allowance(address(this), address(_bestVault)) < amount) {\\n      token.safeApprove(address(_bestVault), 0); // Avoid issues with some tokens requiring 0\\n      token.safeApprove(address(_bestVault), UNLIMITED_APPROVAL); // Vaults are trusted\\n    }\\n\\n    // Depositing returns number of shares deposited\\n    // NOTE: Shortcut here is assuming the number of tokens deposited is equal to the\\n    //       number of shares credited, which helps avoid an occasional multiplication\\n    //       overflow if trying to adjust the number of shares by the share price.\\n    uint256 beforeBal = token.balanceOf(address(this));\\n    _bestVault.deposit(amount, receiver);\\n\\n    uint256 afterBal = token.balanceOf(address(this));\\n    deposited = beforeBal.sub(afterBal);\\n    // `receiver` now has shares of `_bestVault` as balance, converted to `token` here\\n    // Issue a refund if not everything was deposited\\n    if (depositor != address(this) && afterBal > 0) token.safeTransfer(depositor, afterBal);\\n  }\\n\\n  function _withdraw(\\n    address sender,\\n    address receiver,\\n    uint256 amount, // if `MAX_UINT256`, just withdraw everything\\n    bool withdrawFromBest // If true, also withdraw from `_bestVault`\\n  ) internal returns (uint256 withdrawn) {\\n    VaultAPI _bestVault = bestVault();\\n\\n    VaultAPI[] memory vaults = allVaults();\\n    _updateVaultCache(vaults);\\n\\n    // NOTE: This loop will attempt to withdraw from each Vault in `allVaults` that `sender`\\n    //       is deposited in, up to `amount` tokens. The withdraw action can be expensive,\\n    //       so it if there is a denial of service issue in withdrawing, the downstream usage\\n    //       of this wrapper contract must give an alternative method of withdrawing using\\n    //       this function so that `amount` is less than the full amount requested to withdraw\\n    //       (e.g. \\\"piece-wise withdrawals\\\"), leading to less loop iterations such that the\\n    //       DoS issue is mitigated (at a tradeoff of requiring more txns from the end user).\\n    for (uint256 id = 0; id < vaults.length; id++) {\\n      if (!withdrawFromBest && vaults[id] == _bestVault) {\\n        continue; // Don't withdraw from the best\\n      }\\n\\n      // Start with the total shares that `sender` has\\n      uint256 availableShares = vaults[id].balanceOf(sender);\\n\\n      // Restrict by the allowance that `sender` has to this contract\\n      // NOTE: No need for allowance check if `sender` is this contract\\n      if (sender != address(this)) {\\n        availableShares = Math.min(availableShares, vaults[id].allowance(sender, address(this)));\\n      }\\n\\n      // Limit by maximum withdrawal size from each vault\\n      availableShares = Math.min(availableShares, vaults[id].maxAvailableShares());\\n\\n      if (availableShares > 0) {\\n        // Intermediate step to move shares to this contract before withdrawing\\n        // NOTE: No need for share transfer if this contract is `sender`\\n        if (sender != address(this)) vaults[id].transferFrom(sender, address(this), availableShares);\\n\\n        if (amount != WITHDRAW_EVERYTHING) {\\n          // Compute amount to withdraw fully to satisfy the request\\n          uint256 estimatedShares = amount\\n          .sub(withdrawn).mul(10**uint256(vaults[id].decimals())).div(vaults[id].pricePerShare()); // NOTE: Changes every iteration // NOTE: Every Vault is different\\n\\n          // Limit amount to withdraw to the maximum made available to this contract\\n          // NOTE: Avoid corner case where `estimatedShares` isn't precise enough\\n          // NOTE: If `0 < estimatedShares < 1` but `availableShares > 1`, this will withdraw more than necessary\\n          if (estimatedShares > 0 && estimatedShares < availableShares) {\\n            withdrawn = withdrawn.add(vaults[id].withdraw(estimatedShares, address(this)));\\n          } else {\\n            withdrawn = withdrawn.add(vaults[id].withdraw(availableShares, address(this)));\\n          }\\n        } else {\\n          withdrawn = withdrawn.add(vaults[id].withdraw(type(uint256).max, address(this)));\\n        }\\n\\n        // Check if we have fully satisfied the request\\n        // NOTE: use `amount = WITHDRAW_EVERYTHING` for withdrawing everything\\n        if (amount <= withdrawn) break; // withdrawn as much as we needed\\n      }\\n    }\\n\\n    // If we have extra, deposit back into `_bestVault` for `sender`\\n    // NOTE: Invariant is `withdrawn <= amount`\\n    if (withdrawn > amount && withdrawn.sub(amount) > _bestVault.pricePerShare().div(10**_bestVault.decimals())) {\\n      // Don't forget to approve the deposit\\n      if (token.allowance(address(this), address(_bestVault)) < withdrawn.sub(amount)) {\\n        token.safeApprove(address(_bestVault), UNLIMITED_APPROVAL); // Vaults are trusted\\n      }\\n\\n      _bestVault.deposit(withdrawn.sub(amount), sender);\\n      withdrawn = amount;\\n    }\\n\\n    // `receiver` now has `withdrawn` tokens as balance\\n    if (receiver != address(this)) token.safeTransfer(receiver, withdrawn);\\n  }\\n\\n  function _migrate(address account) internal returns (uint256) {\\n    return _migrate(account, MIGRATE_EVERYTHING);\\n  }\\n\\n  function _migrate(address account, uint256 amount) internal returns (uint256) {\\n    // NOTE: In practice, it was discovered that <50 was the maximum we've see for this variance\\n    return _migrate(account, amount, 0);\\n  }\\n\\n  function _migrate(\\n    address account,\\n    uint256 amount,\\n    uint256 maxMigrationLoss\\n  ) internal returns (uint256 migrated) {\\n    VaultAPI _bestVault = bestVault();\\n\\n    // NOTE: Only override if we aren't migrating everything\\n    uint256 _depositLimit = _bestVault.depositLimit();\\n    uint256 _totalAssets = _bestVault.totalAssets();\\n    if (_depositLimit <= _totalAssets) return 0; // Nothing to migrate (not a failure)\\n\\n    uint256 _amount = amount;\\n    if (_depositLimit < UNCAPPED_DEPOSITS && _amount < WITHDRAW_EVERYTHING) {\\n      // Can only deposit up to this amount\\n      uint256 _depositLeft = _depositLimit.sub(_totalAssets);\\n      if (_amount > _depositLeft) _amount = _depositLeft;\\n    }\\n\\n    if (_amount > 0) {\\n      // NOTE: `false` = don't withdraw from `_bestVault`\\n      uint256 withdrawn = _withdraw(account, address(this), _amount, false);\\n      if (withdrawn == 0) return 0; // Nothing to migrate (not a failure)\\n\\n      // NOTE: `false` = don't do `transferFrom` because it's already local\\n      migrated = _deposit(address(this), account, withdrawn, false);\\n      // NOTE: Due to the precision loss of certain calculations, there is a small inefficency\\n      //       on how migrations are calculated, and this could lead to a DoS issue. Hence, this\\n      //       value is made to be configurable to allow the user to specify how much is acceptable\\n      require(withdrawn.sub(migrated) <= maxMigrationLoss);\\n    } // else: nothing to migrate! (not a failure)\\n  }\\n}\\n\",\"keccak256\":\"0xe3927a57c72d92fa24276e1da32d8239a0908b1530119c1c1fc4b61bd1c84154\",\"license\":\"GPL-3.0\"},\"src/extensions/YearnFinanceWrapper.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0 <=0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"hardhat/console.sol\\\";\\n\\nimport {VaultAPI, BaseWrapper} from \\\"./BaseWraper.sol\\\";\\n\\ncontract YearnFinanceWrapper is ERC20, BaseWrapper {\\n  /// @notice The EIP-712 typehash for the contract's domain\\n  bytes32 public constant DOMAIN_TYPEHASH =\\n    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\");\\n  bytes32 public immutable DOMAIN_SEPARATOR;\\n\\n  /// @notice The EIP-712 typehash for the permit struct used by the contract\\n  bytes32 public constant PERMIT_TYPEHASH =\\n    keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n\\n  /// @notice A record of states for signing / validating signatures\\n  mapping(address => uint256) public nonces;\\n\\n  address public affiliate;\\n\\n  address public pendingAffiliate;\\n\\n  modifier onlyAffiliate() {\\n    require(msg.sender == affiliate);\\n    _;\\n  }\\n\\n  constructor(\\n    address _token,\\n    address _registry,\\n    string memory name,\\n    string memory symbol\\n  ) public BaseWrapper(_token, _registry) ERC20(name, symbol) {\\n    DOMAIN_SEPARATOR = keccak256(\\n      abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), keccak256(bytes(\\\"1\\\")), _getChainId(), address(this))\\n    );\\n    affiliate = msg.sender;\\n    // decimals(uint8(ERC20(address(token)).decimals()));\\n  }\\n\\n  function _getChainId() internal view returns (uint256) {\\n    uint256 chainId;\\n    assembly {\\n      chainId := chainid()\\n    }\\n    return chainId;\\n  }\\n\\n  function setAffiliate(address _affiliate) external onlyAffiliate {\\n    pendingAffiliate = _affiliate;\\n  }\\n\\n  function acceptAffiliate() external {\\n    require(msg.sender == pendingAffiliate);\\n    affiliate = msg.sender;\\n  }\\n\\n  function _shareValue(uint256 numShares) internal view returns (uint256) {\\n    uint256 totalShares = totalSupply();\\n\\n    if (totalShares > 0) {\\n      return (totalVaultBalance(address(this)) * (numShares)) / (totalShares);\\n    } else {\\n      return numShares;\\n    }\\n  }\\n\\n  function pricePerShare() public view returns (uint256) {\\n    uint256 pricePerShare;\\n    if (totalSupply() == 0) {\\n      return 1e18;\\n    } else {\\n      pricePerShare = (totalVaultBalance(address(this)) * (10**uint256(decimals()))) / (totalSupply());\\n    }\\n    return pricePerShare;\\n  }\\n\\n  function _sharesForValue(uint256 amount) internal view returns (uint256) {\\n    // total wrapper assets before deposit (assumes deposit already occured)\\n    uint256 totalBalance = totalVaultBalance(address(this));\\n    if (totalBalance > amount) {\\n      return (totalSupply() * (amount)) / (totalBalance - (amount));\\n    } else {\\n      return amount;\\n    }\\n  }\\n\\n  function deposit(uint256 amount) external returns (uint256 deposited) {\\n    deposited = _deposit(msg.sender, address(this), amount, true); // `true` = pull from `msg.sender`\\n    uint256 shares = _sharesForValue(deposited); // NOTE: Must be calculated after deposit is handled\\n    _mint(address(this), shares);\\n  }\\n\\n  function withdraw(address token, uint256 amount, address to) public returns (uint256 withdrawn) {\\n    // Todo addy onlyOwner or roles\\n    uint256 pricePerShare = pricePerShare();\\n    uint256 shares = (amount * (10**uint256(decimals()))) / (pricePerShare);\\n    uint256 balanceOfContract = balanceOf(address(this));\\n\\n    withdrawn = _withdraw(address(this), to, _shareValue(shares), true); // `true` = withdraw from `bestVault`\\n    _burn(address(this), shares);\\n  }\\n\\n  function migrate() external onlyAffiliate returns (uint256) {\\n    return _migrate(address(this));\\n  }\\n\\n  function migrate(uint256 amount) external onlyAffiliate returns (uint256) {\\n    return _migrate(address(this), amount);\\n  }\\n\\n  function migrate(uint256 amount, uint256 maxMigrationLoss) external onlyAffiliate returns (uint256) {\\n    return _migrate(address(this), amount, maxMigrationLoss);\\n  }\\n\\n  /**\\n   * @notice Triggers an approval from owner to spends\\n   * @param owner The address to approve from\\n   * @param spender The address to be approved\\n   * @param amount The number of tokens that are approved (2^256-1 means infinite)\\n   * @param deadline The time at which to expire the signature\\n   * @param v The recovery byte of the signature\\n   * @param r Half of the ECDSA signature pair\\n   * @param s Half of the ECDSA signature pair\\n   */\\n  function permit(\\n    address owner,\\n    address spender,\\n    uint256 amount,\\n    uint256 deadline,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external {\\n    require(owner != address(0), \\\"permit: signature\\\");\\n    require(block.timestamp <= deadline, \\\"permit: expired\\\");\\n\\n    bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, amount, nonces[owner]++, deadline));\\n    bytes32 digest = keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", DOMAIN_SEPARATOR, structHash));\\n\\n    address signatory = ecrecover(digest, v, r, s);\\n    require(signatory == owner, \\\"permit: unauthorized\\\");\\n\\n    _approve(owner, spender, amount);\\n  }\\n\\n  function getReserveNormalizedIncome() public view returns (uint256) {\\n    // TODO: Scale to ray accordingly to the decimals of the token\\n    return pricePerShare() * 1e9; // Scales result to RAY\\n  }\\n}\\n\",\"keccak256\":\"0x45b1bde1e51e349bd225a4b3208d0fa1e98bd5026f8b47ac017214669ab20455\",\"license\":\"MIT\"},\"src/extensions/interfaces/StrategyApi.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0 <=0.8.13;\\n\\n/**\\n * This interface is here for the keeper bot to use.\\n */\\ninterface StrategyAPI {\\n    function name() external view returns (string memory);\\n\\n    function vault() external view returns (address);\\n\\n    function want() external view returns (address);\\n\\n    function apiVersion() external pure returns (string memory);\\n\\n    function keeper() external view returns (address);\\n\\n    function isActive() external view returns (bool);\\n\\n    function delegatedAssets() external view returns (uint256);\\n\\n    function estimatedTotalAssets() external view returns (uint256);\\n\\n    function tendTrigger(uint256 callCost) external view returns (bool);\\n\\n    function tend() external;\\n\\n    function harvestTrigger(uint256 callCost) external view returns (bool);\\n\\n    function harvest() external;\\n\\n    event Harvested(\\n        uint256 profit,\\n        uint256 loss,\\n        uint256 debtPayment,\\n        uint256 debtOutstanding\\n    );\\n}\",\"keccak256\":\"0xf06662684b06def31741f14ac080d7f00c83506ebb68f9aa8779d3690de3b311\",\"license\":\"MIT\"},\"src/extensions/interfaces/VaultApi.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0 <=0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nstruct StrategyParams {\\n    uint256 performanceFee;\\n    uint256 activation;\\n    uint256 debtRatio;\\n    uint256 minDebtPerHarvest;\\n    uint256 maxDebtPerHarvest;\\n    uint256 lastReport;\\n    uint256 totalDebt;\\n    uint256 totalGain;\\n    uint256 totalLoss;\\n}\\n\\ninterface VaultAPI is IERC20 {\\n    function name() external view returns (string calldata);\\n\\n    function symbol() external view returns (string calldata);\\n\\n    function decimals() external view returns (uint256);\\n\\n    function apiVersion() external pure returns (string memory);\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 amount,\\n        uint256 expiry,\\n        bytes calldata signature\\n    ) external returns (bool);\\n\\n    function deposit(uint256 amount, address recipient)\\n        external\\n        returns (uint256);\\n\\n    function withdraw(uint256 assets, address recipient)\\n        external\\n        returns (uint256);\\n\\n    function token() external view returns (address);\\n\\n    function strategies(address _strategy)\\n        external\\n        view\\n        returns (StrategyParams memory);\\n\\n    function pricePerShare() external view returns (uint256);\\n\\n    function totalAssets() external view returns (uint256);\\n\\n    function depositLimit() external view returns (uint256);\\n\\n    function maxAvailableShares() external view returns (uint256);\\n\\n    /**\\n     * View how much the Vault would increase this Strategy's borrow limit,\\n     * based on its present performance (since its last report). Can be used to\\n     * determine expectedReturn in your Strategy.\\n     */\\n    function creditAvailable() external view returns (uint256);\\n\\n    /**\\n     * View how much the Vault would like to pull back from the Strategy,\\n     * based on its present performance (since its last report). Can be used to\\n     * determine expectedReturn in your Strategy.\\n     */\\n    function debtOutstanding() external view returns (uint256);\\n\\n    /**\\n     * View how much the Vault expect this Strategy to return at the current\\n     * block, based on its present performance (since its last report). Can be\\n     * used to determine expectedReturn in your Strategy.\\n     */\\n    function expectedReturn() external view returns (uint256);\\n\\n    /**\\n     * This is the main contact point where the Strategy interacts with the\\n     * Vault. It is critical that this call is handled as intended by the\\n     * Strategy. Therefore, this function will be called by BaseStrategy to\\n     * make sure the integration is correct.\\n     */\\n    function report(\\n        uint256 _gain,\\n        uint256 _loss,\\n        uint256 _debtPayment\\n    ) external returns (uint256);\\n\\n    /**\\n     * This function should only be used in the scenario where the Strategy is\\n     * being retired but no migration of the positions are possible, or in the\\n     * extreme scenario that the Strategy needs to be put into \\\"Emergency Exit\\\"\\n     * mode in order for it to exit as quickly as possible. The latter scenario\\n     * could be for any reason that is considered \\\"critical\\\" that the Strategy\\n     * exits its position as fast as possible, such as a sudden change in\\n     * market conditions leading to losses, or an imminent failure in an\\n     * external dependency.\\n     */\\n    function revokeStrategy() external;\\n\\n    /**\\n     * View the governance address of the Vault to assert privileged functions\\n     * can only be called by governance. The Strategy serves the Vault, so it\\n     * is subject to governance defined by the Vault.\\n     */\\n    function governance() external view returns (address);\\n\\n    /**\\n     * View the management address of the Vault to assert privileged functions\\n     * can only be called by management. The Strategy serves the Vault, so it\\n     * is subject to management defined by the Vault.\\n     */\\n    function management() external view returns (address);\\n\\n    /**\\n     * View the guardian address of the Vault to assert privileged functions\\n     * can only be called by guardian. The Strategy serves the Vault, so it\\n     * is subject to guardian defined by the Vault.\\n     */\\n    function guardian() external view returns (address);\\n}\",\"keccak256\":\"0x09f3c645cfd6459da5e4a69dd9794632f50da00c03626b23b674e0d8972491aa\",\"license\":\"MIT\"},\"src/lib/Errors.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity >=0.8.0 <=0.8.13;\\n\\nlibrary Errors {\\n  // *** Contract Specific Errors ***\\n  // BorrowerPools\\n  error BP_BORROW_MAX_BORROWABLE_AMOUNT_EXCEEDED(); // \\\"Amount borrowed is too big, exceeding borrowable capacity\\\";\\n  error BP_REPAY_NO_ACTIVE_LOAN(); // \\\"No active loan to be repaid, action cannot be performed\\\";\\n  error BP_BORROW_UNSUFFICIENT_BORROWABLE_AMOUNT_WITHIN_BRACKETS(); // \\\"Amount provided is greater than available amount within min rate and max rate brackets\\\";\\n  error BP_REPAY_AT_MATURITY_ONLY(); // \\\"Maturity has not been reached yet, action cannot be performed\\\";\\n  error BP_BORROW_COOLDOWN_PERIOD_NOT_OVER(); // \\\"Cooldown period after a repayment is not over\\\";\\n  error BP_MULTIPLE_BORROW_AFTER_MATURITY(); // \\\"Cannot borrow again from pool after loan maturity\\\";\\n  error BP_POOL_NOT_ACTIVE(); // \\\"Pool not active\\\"\\n  error BP_POOL_DEFAULTED(); // \\\"Pool defaulted\\\"\\n  error BP_LOAN_ONGOING(); // \\\"There's a loan ongoing, cannot update rate\\\"\\n  error BP_BORROW_OUT_OF_BOUND_AMOUNT(); // \\\"Amount provided is greater than available amount, action cannot be performed\\\";\\n  error BP_OUT_OF_BOUND_MIN_RATE(); // \\\"Rate provided is lower than minimum rate of the pool\\\";\\n  error BP_OUT_OF_BOUND_MAX_RATE(); // \\\"Rate provided is greater than maximum rate of the pool\\\";\\n  error BP_UNMATCHED_TOKEN(); // \\\"Token/Asset provided does not match the underlying token of the pool\\\";\\n  error BP_RATE_SPACING(); // \\\"Decimals of rate provided do not comply with rate spacing of the pool\\\";\\n  error BP_BOND_ISSUANCE_ID_TOO_HIGH(); // \\\"Bond issuance id is too high\\\";\\n  error BP_NO_DEPOSIT_TO_WITHDRAW(); // \\\"Deposited amount non-borrowed equals to zero\\\";\\n  error BP_TARGET_BOND_ISSUANCE_INDEX_EMPTY(); // \\\"Target bond issuance index has no amount to withdraw\\\";\\n  error BP_EARLY_REPAY_NOT_ACTIVATED(); // \\\"The early repay feature is not activated for this pool\\\";\\n  error  BP_FLOW_NOT_ENOUGH(); // \\\"The flow is not enough\\\";\\n\\n  // PoolController\\n  error PC_BORROWER_NOT_OWNER(); // \\\"Borrower is not the owner of the pool\\\";\\n  error PC_POOL_NOT_ACTIVE(); // \\\"Pool not active\\\"\\n  error PC_POOL_DEFAULTED(); // \\\"Pool defaulted\\\"\\n  error PC_POOL_ALREADY_SET_FOR_BORROWER(); // \\\"Targeted borrower is already set for another pool\\\";\\n  error PC_POOL_TOKEN_NOT_SUPPORTED(); // \\\"Underlying token is not supported by the yield provider\\\";\\n  error PC_DISALLOW_UNMATCHED_BORROWER(); // \\\"Revoking the wrong borrower as the provided borrower does not match the provided address\\\";\\n  error PC_RATE_SPACING_COMPLIANCE(); // \\\"Provided rate must be compliant with rate spacing\\\";\\n  error PC_NO_ONGOING_LOAN(); // \\\"Cannot default a pool that has no ongoing loan\\\";\\n  error PC_NOT_ENOUGH_PROTOCOL_FEES(); // \\\"Not enough registered protocol fees to withdraw\\\";\\n  error PC_POOL_ALREADY_CLOSED(); // \\\"Pool already closed\\\";\\n  error PC_ZERO_POOL(); // \\\"Cannot make actions on the zero pool\\\";\\n  error PC_ZERO_ADDRESS(); // \\\"Cannot make actions on the zero address\\\";\\n  error PC_REPAYMENT_PERIOD_ONGOING(); // \\\"Cannot default pool while repayment period in ongoing\\\"\\n  error PC_ESTABLISHMENT_FEES_TOO_HIGH(); // \\\"Cannot set establishment fee over 100% of loan amount\\\"\\n  error PC_BORROWER_ALREADY_AUTHORIZED(); // \\\"Borrower already authorized on another pool\\\"\\n\\n  // PositionManager\\n  error POS_MGMT_ONLY_OWNER(); // \\\"Only the owner of the position token can manage it (update rate, withdraw)\\\";\\n  error POS_POSITION_ONLY_IN_BONDS(); // \\\"Cannot withdraw a position that's only in bonds\\\";\\n  error POS_ZERO_AMOUNT(); // \\\"Cannot deposit zero amount\\\";\\n  error POS_TIMELOCK(); // \\\"Cannot withdraw or update rate in the same block as deposit\\\";\\n  error POS_POSITION_DOES_NOT_EXIST(); // \\\"Position does not exist\\\";\\n  error POS_POOL_DEFAULTED(); // \\\"Pool defaulted\\\";\\n  error POS_ZERO_ADDRESS(); // \\\"Cannot make actions on the zero address\\\";\\n  error POS_NOT_ALLOWED(); // \\\"Transaction sender is not allowed to perform the target action\\\";\\n\\n  // PositionDescriptor\\n  error POD_BAD_INPUT(); // \\\"Input pool identifier does not correspond to input pool hash\\\";\\n\\n  //*** Library Specific Errors ***\\n  // WadRayMath\\n  error MATH_MULTIPLICATION_OVERFLOW(); // \\\"The multiplication would result in a overflow\\\";\\n  error MATH_ADDITION_OVERFLOW(); // \\\"The addition would result in a overflow\\\";\\n  error MATH_DIVISION_BY_ZERO(); // \\\"The division would result in a divzion by zero\\\";\\n}\\n\",\"keccak256\":\"0xb61d51c00d8e609b511c2bca5420f62415fba582252efe6c45cf57b6f444588f\",\"license\":\"AGPL-3.0\"},\"src/lib/PoolLogic.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity >=0.8.0 <=0.8.13;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\\\";\\nimport {Rounding} from \\\"./Rounding.sol\\\";\\nimport {Scaling} from \\\"./Scaling.sol\\\";\\nimport {Uint128WadRayMath} from \\\"./Uint128WadRayMath.sol\\\";\\nimport \\\"./Types.sol\\\";\\nimport \\\"./Errors.sol\\\";\\nimport \\\"../extensions/YearnFinanceWrapper.sol\\\";\\n\\nlibrary PoolLogic {\\n  event PoolActivated(address ownerAddress);\\n  enum BalanceUpdateType {\\n    INCREASE,\\n    DECREASE\\n  }\\n  event TickInitialized(address borrower, uint128 rate, uint128 atlendisLiquidityRatio);\\n  event TickLoanDeposit(address borrower, uint128 rate, uint128 adjustedPendingDeposit);\\n  event TickNoLoanDeposit(\\n    address borrower,\\n    uint128 rate,\\n    uint128 adjustedPendingDeposit,\\n    uint128 atlendisLiquidityRatio\\n  );\\n  event TickBorrow(\\n    address borrower,\\n    uint128 rate,\\n    uint128 adjustedRemainingAmountReduction,\\n    uint128 loanedAmount,\\n    uint128 atlendisLiquidityRatio,\\n    uint128 unborrowedRatio\\n  );\\n  event TickWithdrawPending(address borrower, uint128 rate, uint128 adjustedAmountToWithdraw);\\n  event TickWithdrawRemaining(\\n    address borrower,\\n    uint128 rate,\\n    uint128 adjustedAmountToWithdraw,\\n    uint128 atlendisLiquidityRatio,\\n    uint128 accruedFeesToWithdraw\\n  );\\n  event TickPendingDeposit(\\n    address borrower,\\n    uint128 rate,\\n    uint128 adjustedPendingAmount,\\n    bool poolBondIssuanceIndexIncremented\\n  );\\n  event TopUpLiquidityRewards(address borrower, uint128 addedLiquidityRewards);\\n  event TickRepay(address borrower, uint128 rate, uint128 newAdjustedRemainingAmount, uint128 atlendisLiquidityRatio);\\n  event CollectFeesForTick(address borrower, uint128 rate, uint128 remainingLiquidityRewards, uint128 addedAccruedFees);\\n\\n  using PoolLogic for Types.Pool;\\n  using Uint128WadRayMath for uint128;\\n  using Rounding for uint128;\\n  using Scaling for uint128;\\n  using SafeERC20Upgradeable for IERC20Upgradeable;\\n\\n  uint256 public constant SECONDS_PER_YEAR = 365 days;\\n  uint256 public constant WAD = 1e18;\\n  uint256 public constant RAY = 1e27;\\n\\n  /**\\n   * @dev Getter for the multiplier allowing a conversion between pending and deposited\\n   * amounts for the target bonds issuance index\\n   **/\\n  function getBondIssuanceMultiplierForTick(\\n    Types.Pool storage pool,\\n    uint128 rate,\\n    uint128 bondsIssuanceIndex\\n  ) internal view returns (uint128 returnBondsIssuanceMultiplier) {\\n    Types.Tick storage tick = pool.ticks[rate];\\n    returnBondsIssuanceMultiplier = tick.bondsIssuanceIndexMultiplier[bondsIssuanceIndex];\\n    if (returnBondsIssuanceMultiplier == 0) {\\n      returnBondsIssuanceMultiplier = uint128(RAY);\\n    }\\n  }\\n\\n  /**\\n   * @dev Get share of accumulated fees from stored current tick state\\n   **/\\n  function getAccruedFeesShare(\\n    Types.Pool storage pool,\\n    uint128 rate,\\n    uint128 adjustedAmount\\n  ) internal view returns (uint128 accruedFeesShare) {\\n    Types.Tick storage tick = pool.ticks[rate];\\n    accruedFeesShare = tick.accruedFees.wadMul(adjustedAmount).wadDiv(tick.adjustedRemainingAmount);\\n  }\\n\\n  /**\\n   * @dev Get share of accumulated fees from estimated current tick state\\n   **/\\n  function peekAccruedFeesShare(\\n    Types.Pool storage pool,\\n    uint128 rate,\\n    uint128 adjustedAmount,\\n    uint128 accruedFees\\n  ) public view returns (uint128 accruedFeesShare) {\\n    Types.Tick storage tick = pool.ticks[rate];\\n    if (tick.adjustedRemainingAmount == 0) {\\n      return 0;\\n    }\\n    accruedFeesShare = accruedFees.wadMul(adjustedAmount).wadDiv(tick.adjustedRemainingAmount);\\n  }\\n\\n  function getLateRepayFeePerBond(Types.Pool storage pool) public view returns (uint128 lateRepayFeePerBond) {\\n    uint256 lateRepaymentTimestamp = pool.state.currentMaturity + pool.parameters.REPAYMENT_PERIOD;\\n    if (block.timestamp > lateRepaymentTimestamp) {\\n      uint256 referenceTimestamp = pool.state.defaultTimestamp > 0 ? pool.state.defaultTimestamp : block.timestamp;\\n      lateRepayFeePerBond = uint128(\\n        uint256(referenceTimestamp - lateRepaymentTimestamp) * uint256(pool.parameters.LATE_REPAY_FEE_PER_BOND_RATE)\\n      );\\n    }\\n  }\\n\\n  function getRepaymentFees(Types.Pool storage pool, uint128 normalizedRepayAmount)\\n    public\\n    view\\n    returns (uint128 repaymentFees)\\n  {\\n    repaymentFees = (normalizedRepayAmount - pool.state.normalizedBorrowedAmount).wadMul(\\n      pool.parameters.REPAYMENT_FEE_RATE\\n    );\\n  }\\n\\n  /**\\n   * @dev The return value includes only notional and accrued interest,\\n   * it does not include any fees due for repay by the borrrower\\n   **/\\n  function getRepayValue(Types.Pool storage pool, bool earlyRepay) public view returns (uint128 repayValue) {\\n    if (pool.state.currentMaturity == 0) {\\n      return 0;\\n    }\\n    if (!earlyRepay) {\\n      // Note: Despite being in the context of a none early repay we prevent underflow in case of wrong user input\\n      // and allow querying expected bonds quantity if loan is repaid at maturity\\n      if (block.timestamp <= pool.state.currentMaturity) {\\n        return pool.state.bondsIssuedQuantity;\\n      }\\n    }\\n    for (\\n      uint128 rate = pool.state.lowerInterestRate;\\n      rate <= pool.parameters.MAX_RATE;\\n      rate += pool.parameters.RATE_SPACING\\n    ) {\\n      Types.Tick storage tick = pool.ticks[rate];\\n      repayValue += getTimeValue(pool, tick.bondsQuantity, rate);\\n    }\\n  }\\n\\n  function getTimeValue(\\n    Types.Pool storage pool,\\n    uint128 bondsQuantity,\\n    uint128 rate\\n  ) public view returns (uint128) {\\n    if (block.timestamp <= pool.state.currentMaturity) {\\n      return bondsQuantity.wadMul(getTickBondPrice(rate, uint128(pool.state.currentMaturity - block.timestamp)));\\n    }\\n    uint256 referenceTimestamp = uint128(block.timestamp);\\n    if (pool.state.defaultTimestamp > 0) {\\n      referenceTimestamp = pool.state.defaultTimestamp;\\n    }\\n    return bondsQuantity.wadDiv(getTickBondPrice(rate, uint128(referenceTimestamp - pool.state.currentMaturity)));\\n  }\\n\\n  /**\\n   * @dev Deposit to a target tick\\n   * Updates tick data\\n   **/\\n  function depositToTick(\\n    Types.Pool storage pool,\\n    uint128 rate,\\n    uint128 normalizedAmount\\n  ) public returns (uint128 adjustedAmount, uint128 returnBondsIssuanceIndex) {\\n    Types.Tick storage tick = pool.ticks[rate];\\n\\n    pool.collectFees(rate);\\n\\n    // if there is an ongoing loan, the deposited amount goes to the pending\\n    // quantity and will be considered for next loan\\n    if (pool.state.currentMaturity > 0) {\\n      adjustedAmount = normalizedAmount.wadRayDiv(tick.yieldProviderLiquidityRatio);\\n      tick.adjustedPendingAmount += adjustedAmount;\\n      returnBondsIssuanceIndex = pool.state.currentBondsIssuanceIndex + 1;\\n      emit TickLoanDeposit(pool.parameters.OWNER, rate, adjustedAmount);\\n    }\\n    // if there is no ongoing loan, the deposited amount goes to total and remaining\\n    // amount and can be borrowed instantaneously\\n    else {\\n      uint128 atlendisLiquidityRatio = tick.atlendisLiquidityRatio;\\n      (\\\"atlendisLiquidityRatio\\\", atlendisLiquidityRatio);\\n      adjustedAmount = normalizedAmount.wadRayDiv(tick.atlendisLiquidityRatio);\\n      tick.adjustedTotalAmount += adjustedAmount;\\n      tick.adjustedRemainingAmount += adjustedAmount;\\n      returnBondsIssuanceIndex = pool.state.currentBondsIssuanceIndex;\\n      pool.state.normalizedAvailableDeposits += normalizedAmount;\\n\\n      // return amount adapted to bond index\\n      adjustedAmount = adjustedAmount.wadRayDiv(\\n        pool.getBondIssuanceMultiplierForTick(rate, pool.state.currentBondsIssuanceIndex)\\n      );\\n      emit TickNoLoanDeposit(pool.parameters.OWNER, rate, adjustedAmount, tick.atlendisLiquidityRatio);\\n    }\\n    if ((pool.state.lowerInterestRate == 0) || (rate < pool.state.lowerInterestRate)) {\\n      pool.state.lowerInterestRate = rate;\\n    }\\n  }\\n\\n  /**\\n   * @dev Computes the quantity of bonds purchased, and the equivalent adjusted deposit amount used for the issuance\\n   **/\\nfunction getBondsIssuanceParametersForTick(\\n    Types.Pool storage pool,\\n    uint128 rate,\\n    uint128 normalizedRemainingAmount\\n  ) public returns (uint128 bondsPurchasedQuantity, uint128 normalizedUsedAmount) {\\n    Types.Tick storage tick = pool.ticks[rate];\\n\\n    if (tick.adjustedRemainingAmount.wadRayMul(tick.atlendisLiquidityRatio) >= normalizedRemainingAmount) {\\n      normalizedUsedAmount = normalizedRemainingAmount;\\n    } else if (\\n      tick.adjustedRemainingAmount.wadRayMul(tick.atlendisLiquidityRatio) + tick.accruedFees >=\\n      normalizedRemainingAmount\\n    ) {\\n      normalizedUsedAmount = normalizedRemainingAmount;\\n      tick.accruedFees -=\\n        normalizedRemainingAmount -\\n        tick.adjustedRemainingAmount.wadRayMul(tick.atlendisLiquidityRatio);\\n    } else {\\n      normalizedUsedAmount = tick.adjustedRemainingAmount.wadRayMul(tick.atlendisLiquidityRatio) + tick.accruedFees;\\n      tick.accruedFees = 0;\\n    }\\n    uint128 bondsPurchasePrice = getTickBondPrice(\\n      rate,\\n      pool.state.currentMaturity == 0\\n        ? pool.parameters.LOAN_DURATION\\n        : pool.state.currentMaturity - uint128(block.timestamp)\\n    );\\n    bondsPurchasedQuantity = normalizedUsedAmount.wadDiv(bondsPurchasePrice);\\n  }\\n\\n  function getBondsIssuanceParametersForTickView(\\n    Types.Pool storage pool,\\n    uint128 rate,\\n    uint128 normalizedRemainingAmount\\n  ) internal view returns (uint128 bondsPurchasedQuantity, uint128 normalizedUsedAmount) {\\n    Types.Tick storage tick = pool.ticks[rate];\\n\\n    if (tick.adjustedRemainingAmount.wadRayMul(tick.atlendisLiquidityRatio) >= normalizedRemainingAmount) {\\n      normalizedUsedAmount = normalizedRemainingAmount;\\n    } else if (\\n      tick.adjustedRemainingAmount.wadRayMul(tick.atlendisLiquidityRatio) + tick.accruedFees >=\\n      normalizedRemainingAmount\\n    ) {\\n      normalizedUsedAmount = normalizedRemainingAmount;\\n    } else {\\n      normalizedUsedAmount = tick.adjustedRemainingAmount.wadRayMul(tick.atlendisLiquidityRatio) + tick.accruedFees;\\n    }\\n    uint128 bondsPurchasePrice = getTickBondPrice(\\n      rate,\\n      pool.state.currentMaturity == 0\\n        ? pool.parameters.LOAN_DURATION\\n        : pool.state.currentMaturity - uint128(block.timestamp)\\n    );\\n    bondsPurchasedQuantity = normalizedUsedAmount.wadDiv(bondsPurchasePrice);\\n  }\\n\\n  /**\\n   * @dev Computes the quantity of bonds that would be purchased.\\n   **/\\nfunction calculateBondIssuanceForTick(\\n    Types.Pool storage pool,\\n    uint128 rate,\\n    uint128 normalizedRemainingAmount\\n  ) public view returns (uint128 bondsPurchasedQuantity, uint128 normalizedUsedAmount) {\\n    Types.Tick storage tick = pool.ticks[rate];\\n\\n    if (tick.adjustedRemainingAmount.wadRayMul(tick.atlendisLiquidityRatio) >= normalizedRemainingAmount) {\\n      normalizedUsedAmount = normalizedRemainingAmount;\\n    } else if (\\n      tick.adjustedRemainingAmount.wadRayMul(tick.atlendisLiquidityRatio) + tick.accruedFees >=\\n      normalizedRemainingAmount\\n    ) {\\n      normalizedUsedAmount = normalizedRemainingAmount;\\n    } else {\\n      normalizedUsedAmount = tick.adjustedRemainingAmount.wadRayMul(tick.atlendisLiquidityRatio) + tick.accruedFees;\\n    }\\n    uint128 bondsPurchasePrice = getTickBondPrice(\\n      rate,\\n      pool.state.currentMaturity == 0\\n        ? pool.parameters.LOAN_DURATION\\n        : pool.state.currentMaturity - uint128(block.timestamp)\\n    );\\n    bondsPurchasedQuantity = normalizedUsedAmount.wadDiv(bondsPurchasePrice);\\n  }\\n\\n  /**\\n   * @dev Makes all the state changes necessary to add bonds to a tick\\n   * Updates tick data and conversion data\\n   **/\\n  function addBondsToTick(\\n    Types.Pool storage pool,\\n    uint128 rate,\\n    uint128 bondsIssuedQuantity,\\n    uint128 normalizedUsedAmountForPurchase\\n  ) public {\\n    Types.Tick storage tick = pool.ticks[rate];\\n\\n    // update global state for tick and pool\\n    tick.bondsQuantity += bondsIssuedQuantity;\\n    uint128 adjustedAmountForPurchase = normalizedUsedAmountForPurchase.wadRayDiv(tick.atlendisLiquidityRatio);\\n    if (adjustedAmountForPurchase > tick.adjustedRemainingAmount) {\\n      adjustedAmountForPurchase = tick.adjustedRemainingAmount;\\n    }\\n    tick.adjustedRemainingAmount -= adjustedAmountForPurchase;\\n    tick.normalizedLoanedAmount += normalizedUsedAmountForPurchase;\\n    // emit event with tick updates\\n    uint128 unborrowedRatio = tick.adjustedRemainingAmount.wadDiv(tick.adjustedTotalAmount);\\n    emit TickBorrow(\\n      pool.parameters.OWNER,\\n      rate,\\n      adjustedAmountForPurchase,\\n      normalizedUsedAmountForPurchase,\\n      tick.atlendisLiquidityRatio,\\n      unborrowedRatio\\n    );\\n    pool.state.bondsIssuedQuantity += bondsIssuedQuantity;\\n    pool.state.normalizedAvailableDeposits -= normalizedUsedAmountForPurchase;\\n  }\\n\\n  /**\\n   * @dev Computes how the position is split between deposit and bonds\\n   **/\\n  function computeAmountRepartitionForTick(\\n    Types.Pool storage pool,\\n    uint128 rate,\\n    uint128 adjustedAmount,\\n    uint128 bondsIssuanceIndex\\n  ) public view returns (uint128 bondsQuantity, uint128 adjustedDepositedAmount) {\\n    Types.Tick storage tick = pool.ticks[rate];\\n\\n    if (bondsIssuanceIndex > pool.state.currentBondsIssuanceIndex) {\\n      return (0, adjustedAmount);\\n    }\\n\\n    adjustedAmount = adjustedAmount.wadRayMul(pool.getBondIssuanceMultiplierForTick(rate, bondsIssuanceIndex));\\n    uint128 adjustedAmountUsedForBondsIssuance;\\n    if (tick.adjustedTotalAmount > 0) {\\n      adjustedAmountUsedForBondsIssuance = adjustedAmount\\n        .wadMul(tick.adjustedTotalAmount - tick.adjustedRemainingAmount)\\n        .wadDiv(tick.adjustedTotalAmount + tick.adjustedWithdrawnAmount);\\n    }\\n\\n    if (adjustedAmount >= adjustedAmountUsedForBondsIssuance) {\\n      if (tick.adjustedTotalAmount > tick.adjustedRemainingAmount) {\\n        bondsQuantity = tick.bondsQuantity.wadMul(adjustedAmountUsedForBondsIssuance).wadDiv(\\n          tick.adjustedTotalAmount - tick.adjustedRemainingAmount\\n        );\\n      }\\n      adjustedDepositedAmount = (adjustedAmount - adjustedAmountUsedForBondsIssuance);\\n    } else {\\n      /**\\n       * This condition is obtained when precision problems occur in the computation of `adjustedAmountUsedForBondsIssuance`.\\n       * Such problems have been observed when dealing with amounts way lower than a WAD.\\n       * In this case, the remaining and withdrawn amounts are assumed at 0.\\n       * Therefore, the deposited amount is returned as 0 and the bonds quantity is computed using only the adjusted total amount.\\n       */\\n      bondsQuantity = tick.bondsQuantity.wadMul(adjustedAmount).wadDiv(tick.adjustedTotalAmount);\\n      adjustedDepositedAmount = 0;\\n    }\\n  }\\n\\n  /**\\n   * @dev Updates tick data after a withdrawal consisting of only amount deposited to yield provider\\n   **/\\n  function withdrawDepositedAmountForTick(\\n    Types.Pool storage pool,\\n    uint128 rate,\\n    uint128 adjustedAmountToWithdraw,\\n    uint128 bondsIssuanceIndex\\n  ) public returns (uint128 normalizedAmountToWithdraw) {\\n    Types.Tick storage tick = pool.ticks[rate];\\n\\n    pool.collectFees(rate);\\n\\n    if (bondsIssuanceIndex <= pool.state.currentBondsIssuanceIndex) {\\n      uint128 feesShareToWithdraw = pool.getAccruedFeesShare(rate, adjustedAmountToWithdraw);\\n      tick.accruedFees -= feesShareToWithdraw;\\n      tick.adjustedTotalAmount -= adjustedAmountToWithdraw;\\n      tick.adjustedRemainingAmount -= adjustedAmountToWithdraw;\\n\\n      normalizedAmountToWithdraw =\\n        adjustedAmountToWithdraw.wadRayMul(tick.atlendisLiquidityRatio) +\\n        feesShareToWithdraw;\\n      pool.state.normalizedAvailableDeposits -= normalizedAmountToWithdraw.round();\\n\\n      // register withdrawn amount from partially matched positions\\n      // to maintain the proportion of bonds in each subsequent position the same\\n      if (tick.bondsQuantity > 0) {\\n        tick.adjustedWithdrawnAmount += adjustedAmountToWithdraw;\\n      }\\n      emit TickWithdrawRemaining(\\n        pool.parameters.OWNER,\\n        rate,\\n        adjustedAmountToWithdraw,\\n        tick.atlendisLiquidityRatio,\\n        feesShareToWithdraw\\n      );\\n    } else {\\n      tick.adjustedPendingAmount -= adjustedAmountToWithdraw;\\n      normalizedAmountToWithdraw = adjustedAmountToWithdraw.wadRayMul(tick.yieldProviderLiquidityRatio);\\n      emit TickWithdrawPending(pool.parameters.OWNER, rate, adjustedAmountToWithdraw);\\n    }\\n\\n    // update lowerInterestRate if necessary\\n    if ((rate == pool.state.lowerInterestRate) && tick.adjustedTotalAmount == 0) {\\n      uint128 nextRate = rate + pool.parameters.RATE_SPACING;\\n      while (nextRate <= pool.parameters.MAX_RATE && pool.ticks[nextRate].adjustedTotalAmount == 0) {\\n        nextRate += pool.parameters.RATE_SPACING;\\n      }\\n      if (nextRate >= pool.parameters.MAX_RATE) {\\n        pool.state.lowerInterestRate = 0;\\n      } else {\\n        pool.state.lowerInterestRate = nextRate;\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @dev Updates tick data after a repayment\\n   **/\\n  function repayForTick(\\n    Types.Pool storage pool,\\n    uint128 rate,\\n    uint128 lateRepayFeePerBond\\n  ) public returns (uint128 normalizedRepayAmountForTick, uint128 lateRepayFeeForTick) {\\n    Types.Tick storage tick = pool.ticks[rate];\\n\\n    if (tick.bondsQuantity > 0) {\\n      normalizedRepayAmountForTick = getTimeValue(pool, tick.bondsQuantity, rate);\\n      lateRepayFeeForTick = lateRepayFeePerBond.wadMul(normalizedRepayAmountForTick);\\n      uint128 bondPaidInterests = normalizedRepayAmountForTick - tick.normalizedLoanedAmount;\\n      // update liquidity ratio with interests from bonds, yield provider and liquidity rewards\\n      tick.atlendisLiquidityRatio += (tick.accruedFees + bondPaidInterests + lateRepayFeeForTick)\\n        .wadDiv(tick.adjustedTotalAmount)\\n        .wadToRay();\\n\\n      // update tick amounts\\n      tick.bondsQuantity = 0;\\n      tick.adjustedWithdrawnAmount = 0;\\n      tick.normalizedLoanedAmount = 0;\\n      tick.accruedFees = 0;\\n      tick.adjustedRemainingAmount = tick.adjustedTotalAmount;\\n      emit TickRepay(pool.parameters.OWNER, rate, tick.adjustedTotalAmount, tick.atlendisLiquidityRatio);\\n    }\\n  }\\n\\n  /**\\n   * @dev Updates tick data after a repayment\\n   **/\\n  function includePendingDepositsForTick(\\n    Types.Pool storage pool,\\n    uint128 rate,\\n    bool bondsIssuanceIndexAlreadyIncremented\\n  ) internal returns (bool pendingDepositsExist) {\\n    Types.Tick storage tick = pool.ticks[rate];\\n\\n    if (tick.adjustedPendingAmount > 0) {\\n      if (!bondsIssuanceIndexAlreadyIncremented) {\\n        pool.state.currentBondsIssuanceIndex += 1;\\n      }\\n      // include pending deposit amount into tick excluding them from bonds interest from current issuance\\n      tick.bondsIssuanceIndexMultiplier[pool.state.currentBondsIssuanceIndex] = pool\\n        .state\\n        .yieldProviderLiquidityRatio\\n        .rayDiv(tick.atlendisLiquidityRatio);\\n      uint128 adjustedPendingAmount = tick.adjustedPendingAmount.wadRayMul(\\n        tick.bondsIssuanceIndexMultiplier[pool.state.currentBondsIssuanceIndex]\\n      );\\n\\n      // update global pool state\\n      pool.state.normalizedAvailableDeposits += tick.adjustedPendingAmount.wadRayMul(\\n        pool.state.yieldProviderLiquidityRatio\\n      );\\n\\n      // update tick amounts\\n      tick.adjustedTotalAmount += adjustedPendingAmount;\\n      tick.adjustedRemainingAmount = tick.adjustedTotalAmount;\\n      tick.adjustedPendingAmount = 0;\\n      emit TickPendingDeposit(\\n        pool.parameters.OWNER,\\n        rate,\\n        adjustedPendingAmount,\\n        !bondsIssuanceIndexAlreadyIncremented\\n      );\\n      return true;\\n    }\\n    return false;\\n  }\\n\\n  /**\\n   * @dev Top up liquidity rewards for later distribution\\n   **/\\n  function topUpLiquidityRewards(Types.Pool storage pool, uint128 normalizedAmount)\\n    public\\n    returns (uint128 yieldProviderLiquidityRatio)\\n  {\\n    yieldProviderLiquidityRatio = uint128(\\n      pool.parameters.YIELD_PROVIDER.getReserveNormalizedIncome()\\n    );\\n    pool.state.remainingAdjustedLiquidityRewardsReserve += normalizedAmount.wadRayDiv(yieldProviderLiquidityRatio);\\n  }\\n\\n  /**\\n   * @dev Distributes remaining liquidity rewards reserve to lenders\\n   * Called in case of pool default\\n   **/\\n  function distributeLiquidityRewards(Types.Pool storage pool) public returns (uint128 distributedLiquidityRewards) {\\n    uint128 currentInterestRate = pool.state.lowerInterestRate;\\n\\n    uint128 yieldProviderLiquidityRatio = uint128(\\n      pool.parameters.YIELD_PROVIDER.getReserveNormalizedIncome()\\n    );\\n\\n    distributedLiquidityRewards = pool.state.remainingAdjustedLiquidityRewardsReserve.wadRayMul(\\n      yieldProviderLiquidityRatio\\n    );\\n    pool.state.normalizedAvailableDeposits += distributedLiquidityRewards;\\n    pool.state.remainingAdjustedLiquidityRewardsReserve = 0;\\n\\n    while (pool.ticks[currentInterestRate].bondsQuantity > 0 && currentInterestRate <= pool.parameters.MAX_RATE) {\\n      pool.ticks[currentInterestRate].accruedFees += distributedLiquidityRewards\\n        .wadMul(pool.ticks[currentInterestRate].bondsQuantity)\\n        .wadDiv(pool.state.bondsIssuedQuantity);\\n      currentInterestRate += pool.parameters.RATE_SPACING;\\n    }\\n  }\\n\\n  /**\\n   * @dev Updates tick data to reflect all fees accrued since last call\\n   * Accrued fees are composed of the yield provider liquidity ratio increase\\n   * and liquidity rewards paid by the borrower\\n   **/\\n  function collectFeesForTick(\\n    Types.Pool storage pool,\\n    uint128 rate,\\n    uint128 yieldProviderLiquidityRatio\\n  ) internal {\\n    Types.Tick storage tick = pool.ticks[rate];\\n    (\\\"interestRate\\\", rate);\\n    if (tick.lastFeeDistributionTimestamp < block.timestamp) {\\n      (\\n        uint128 updatedAtlendisLiquidityRatio,\\n        uint128 updatedAccruedFees,\\n        uint128 liquidityRewardsIncrease,\\n        uint128 yieldProviderLiquidityRatioIncrease\\n      ) = pool.peekFeesForTick(rate, yieldProviderLiquidityRatio);\\n      // update global deposited amount\\n      pool.state.remainingAdjustedLiquidityRewardsReserve -= liquidityRewardsIncrease.wadRayDiv(\\n        yieldProviderLiquidityRatio\\n      );\\n      pool.state.normalizedAvailableDeposits +=\\n        liquidityRewardsIncrease +\\n        tick.adjustedRemainingAmount.wadRayMul(yieldProviderLiquidityRatioIncrease);\\n\\n      // update tick data\\n      uint128 accruedFeesIncrease = updatedAccruedFees - tick.accruedFees;\\n      if (tick.atlendisLiquidityRatio == 0) {\\n        tick.yieldProviderLiquidityRatio = yieldProviderLiquidityRatio;\\n        emit TickInitialized(pool.parameters.OWNER, rate, yieldProviderLiquidityRatio);\\n      }\\n      tick.atlendisLiquidityRatio = updatedAtlendisLiquidityRatio;\\n      tick.accruedFees = updatedAccruedFees;\\n\\n      // update checkpoint data\\n      tick.lastFeeDistributionTimestamp = uint128(block.timestamp);\\n\\n      emit CollectFeesForTick(\\n        pool.parameters.OWNER,\\n        rate,\\n        pool.state.remainingAdjustedLiquidityRewardsReserve.wadRayMul(yieldProviderLiquidityRatio),\\n        accruedFeesIncrease\\n      );\\n    }\\n  }\\n\\n  function collectFees(Types.Pool storage pool, uint128 rate) internal {\\n    uint128 yieldProviderLiquidityRatio = uint128(\\n      pool.parameters.YIELD_PROVIDER.getReserveNormalizedIncome()\\n    );\\n    (\\\"0yieldProviderLiquidityRatio\\\", yieldProviderLiquidityRatio);\\n    pool.collectFeesForTick(rate, yieldProviderLiquidityRatio);\\n    pool.ticks[rate].yieldProviderLiquidityRatio = yieldProviderLiquidityRatio;\\n  }\\n\\n  function collectFees(Types.Pool storage pool) internal {\\n    uint128 yieldProviderLiquidityRatio = uint128(\\n      pool.parameters.YIELD_PROVIDER.getReserveNormalizedIncome()\\n    );\\n    (\\\"!! yieldProviderLiquidityRatio\\\", yieldProviderLiquidityRatio);\\n    for (\\n      uint128 currentInterestRate = pool.state.lowerInterestRate;\\n      currentInterestRate <= pool.parameters.MAX_RATE;\\n      currentInterestRate += pool.parameters.RATE_SPACING\\n    ) {\\n      pool.collectFeesForTick(currentInterestRate, yieldProviderLiquidityRatio);\\n    }\\n    pool.state.yieldProviderLiquidityRatio = yieldProviderLiquidityRatio;\\n  }\\n\\n  /**\\n   * @dev Peek updated liquidity ratio and accrued fess for the target tick\\n   * Used to compute a position balance without updating storage\\n   **/\\n  function peekFeesForTick(\\n    Types.Pool storage pool,\\n    uint128 rate,\\n    uint128 yieldProviderLiquidityRatio\\n  )\\n    internal\\n    view\\n    returns (\\n      uint128 updatedAtlendisLiquidityRatio,\\n      uint128 updatedAccruedFees,\\n      uint128 liquidityRewardsIncrease,\\n      uint128 yieldProviderLiquidityRatioIncrease\\n    )\\n  {\\n    Types.Tick storage tick = pool.ticks[rate];\\n\\n    if (tick.atlendisLiquidityRatio == 0) {\\n      return (yieldProviderLiquidityRatio, 0, 0, 0);\\n    }\\n\\n    updatedAtlendisLiquidityRatio = tick.atlendisLiquidityRatio;\\n    updatedAccruedFees = tick.accruedFees;\\n\\n    uint128 referenceLiquidityRatio;\\n    if (pool.state.yieldProviderLiquidityRatio > tick.yieldProviderLiquidityRatio) {\\n      referenceLiquidityRatio = pool.state.yieldProviderLiquidityRatio;\\n    } else {\\n      referenceLiquidityRatio = tick.yieldProviderLiquidityRatio;\\n    }\\n    (\\\"referenceLiquidityRatio\\\", referenceLiquidityRatio);\\n    (\\\"yieldProviderLiquidityRatio\\\", yieldProviderLiquidityRatio);\\n    yieldProviderLiquidityRatioIncrease = yieldProviderLiquidityRatio - referenceLiquidityRatio;\\n\\n    // get additional fees from liquidity rewards\\n    liquidityRewardsIncrease = pool.getLiquidityRewardsIncrease(rate);\\n    uint128 currentNormalizedRemainingLiquidityRewards = pool.state.remainingAdjustedLiquidityRewardsReserve.wadRayMul(\\n      yieldProviderLiquidityRatio\\n    );\\n    if (liquidityRewardsIncrease > currentNormalizedRemainingLiquidityRewards) {\\n      liquidityRewardsIncrease = currentNormalizedRemainingLiquidityRewards;\\n    }\\n    // if no ongoing loan, all deposited amount gets the yield provider\\n    // and liquidity rewards so the global liquidity ratio is updated\\n    if (pool.state.currentMaturity == 0) {\\n      updatedAtlendisLiquidityRatio += yieldProviderLiquidityRatioIncrease;\\n      if (tick.adjustedRemainingAmount > 0) {\\n        updatedAtlendisLiquidityRatio += liquidityRewardsIncrease.wadToRay().wadDiv(tick.adjustedRemainingAmount);\\n      }\\n    }\\n    // if ongoing loan, accruing fees components are added, liquidity ratio will be updated at repay time\\n    else {\\n      updatedAccruedFees +=\\n        tick.adjustedRemainingAmount.wadRayMul(yieldProviderLiquidityRatioIncrease) +\\n        liquidityRewardsIncrease;\\n    }\\n    uint128 yearnLiquidity = pool.state.yieldProviderLiquidityRatio;\\n  }\\n\\n  /**\\n   * @dev Computes liquidity rewards amount to be paid to lenders since last fee collection\\n   * Liquidity rewards are paid to the unborrowed amount, and distributed to all ticks depending\\n   * on their normalized amounts\\n   **/\\n  function getLiquidityRewardsIncrease(Types.Pool storage pool, uint128 rate)\\n    internal\\n    view\\n    returns (uint128 liquidityRewardsIncrease)\\n  {\\n    Types.Tick storage tick = pool.ticks[rate];\\n    if (pool.state.normalizedAvailableDeposits > 0) {\\n      liquidityRewardsIncrease = (pool.parameters.LIQUIDITY_REWARDS_DISTRIBUTION_RATE *\\n        (uint128(block.timestamp) - tick.lastFeeDistributionTimestamp))\\n        .wadMul(pool.parameters.MAX_BORROWABLE_AMOUNT - pool.state.normalizedBorrowedAmount)\\n        .wadDiv(pool.parameters.MAX_BORROWABLE_AMOUNT)\\n        .wadMul(tick.adjustedRemainingAmount.wadRayMul(tick.atlendisLiquidityRatio))\\n        .wadDiv(pool.state.normalizedAvailableDeposits);\\n    }\\n  }\\n\\n  /** \\n    * @notice Calculates the proce per bond accordingly to rate and loanDuration \\n    * @param rate The rate of the loan\\n    * @param loanDuration The duration of the loan\\n    * @return price The price per bond\\n    **/\\n  function getTickBondPrice(uint128 rate, uint128 loanDuration) public pure returns (uint128 price) {\\n    price = uint128(WAD).wadDiv(uint128(WAD + (uint256(rate) * uint256(loanDuration)) / uint256(SECONDS_PER_YEAR)));\\n  }\\n\\n  function depositToYieldProvider(\\n    Types.Pool storage pool,\\n    address from,\\n    uint128 normalizedAmount\\n  ) public {\\n    IERC20Upgradeable underlyingToken = IERC20Upgradeable(pool.parameters.UNDERLYING_TOKEN);\\n    uint128 scaledAmount = normalizedAmount.scaleFromWad(pool.parameters.TOKEN_DECIMALS);\\n\\n    YearnFinanceWrapper yieldProvider = pool.parameters.YIELD_PROVIDER;\\n    underlyingToken.safeIncreaseAllowance(address(yieldProvider), scaledAmount);\\n    underlyingToken.safeTransferFrom(from, address(this), scaledAmount);\\n\\n    yieldProvider.deposit(scaledAmount);\\n  }\\n\\n  /**\\n    * @notice Get repaymentAmount for a given loanAmount\\n    * @param loanAmount The total amount of the loan\\n    * @return repaymentAmount The total amount to be repaid \\n  **/\\n  function _getRepaymentAmount(Types.Pool storage pool, uint128 loanAmount) external view returns (uint128 repaymentAmount) {\\n\\n    uint128 normalizedLoanAmount = loanAmount.scaleToWad(pool.parameters.TOKEN_DECIMALS);\\n    uint128 normalizedEstablishmentFee = normalizedLoanAmount.wadMul(pool.parameters.ESTABLISHMENT_FEE_RATE);\\n    repaymentAmount = normalizedEstablishmentFee;\\n\\n    uint128 remainingAmount = normalizedLoanAmount;\\n    uint128 currentInterestRate = pool.state.lowerInterestRate - pool.parameters.RATE_SPACING;\\n\\n    while (remainingAmount > 0 && currentInterestRate < pool.parameters.MAX_RATE) {\\n      currentInterestRate += pool.parameters.RATE_SPACING;\\n      if (pool.ticks[currentInterestRate].adjustedRemainingAmount > 0) {\\n        (uint128 bondsPurchasedQuantity, uint128 normalizedUsedAmountForPurchase) = pool\\n          .getBondsIssuanceParametersForTickView(currentInterestRate, remainingAmount);\\n        remainingAmount -= normalizedUsedAmountForPurchase;\\n        repaymentAmount += bondsPurchasedQuantity.wadMul(getTickBondPrice(currentInterestRate, uint128(0)));\\n      }\\n    }\\n  }\\n\\n\\n}\\n\",\"keccak256\":\"0x8aa9473d8f2a02e2ffe3f1f14d38b91b22b5202ff70e1670422227d6a95fe276\",\"license\":\"AGPL-3.0\"},\"src/lib/Rounding.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity >=0.8.0 <=0.8.13;\\n\\n/**\\n * @title Rounding library\\n * @author Atlendis\\n * @dev Rounding utilities to mitigate precision loss when doing wad ray math operations\\n **/\\nlibrary Rounding {\\n  using Rounding for uint128;\\n\\n  uint128 internal constant PRECISION = 1e3;\\n\\n  /**\\n   * @notice rounds the input number with the default precision\\n   **/\\n  function round(uint128 amount) internal pure returns (uint128) {\\n    return (amount / PRECISION) * PRECISION;\\n  }\\n}\\n\",\"keccak256\":\"0x8006138c859e7b0cb362c60387987d17a19f1bf87cbab7733cfae0823bcfef69\",\"license\":\"AGPL-3.0\"},\"src/lib/Scaling.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity >=0.8.0 <=0.8.13;\\n\\n/**\\n * @title Scaling library\\n * @author Atlendis\\n * @dev Scale an arbitrary number to or from WAD precision\\n **/\\nlibrary Scaling {\\n  uint256 internal constant WAD = 1e18;\\n\\n  /**\\n   * @notice Scales an input amount to wad precision\\n   **/\\n  function scaleToWad(uint128 a, uint256 precision) internal pure returns (uint128) {\\n    return uint128((uint256(a) * WAD) / 10**precision);\\n  }\\n\\n  /**\\n   * @notice Scales an input amount from wad to target precision\\n   **/\\n  function scaleFromWad(uint128 a, uint256 precision) internal pure returns (uint128) {\\n    return uint128((uint256(a) * 10**precision) / WAD);\\n  }\\n}\\n\",\"keccak256\":\"0x600b720c8f046ea5706403630801a961eae43c1b9ee7dc314de8611317b328c7\",\"license\":\"AGPL-3.0\"},\"src/lib/Types.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity >=0.8.0 <=0.8.13;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\n\\nimport \\\"../extensions/YearnFinanceWrapper.sol\\\";\\n\\nlibrary Types {\\n  struct PositionDetails {\\n    uint128 adjustedBalance;\\n    uint128 rate;\\n    address ownerAddress;\\n    address underlyingToken;\\n    uint128 bondsIssuanceIndex;\\n    uint128 remainingBonds;\\n    uint128 bondsMaturity;\\n    uint128 creationTimestamp;\\n  }\\n\\n  struct Tick {\\n    mapping(uint128 => uint128) bondsIssuanceIndexMultiplier;\\n    uint128 bondsQuantity;\\n    uint128 adjustedTotalAmount;\\n    uint128 adjustedRemainingAmount;\\n    uint128 adjustedWithdrawnAmount;\\n    uint128 adjustedPendingAmount;\\n    uint128 normalizedLoanedAmount;\\n    uint128 lastFeeDistributionTimestamp;\\n    uint128 atlendisLiquidityRatio;\\n    uint128 yieldProviderLiquidityRatio;\\n    uint128 accruedFees;\\n  }\\n\\n  struct PoolParameters {\\n    address OWNER;\\n    address UNDERLYING_TOKEN;\\n    uint8 TOKEN_DECIMALS;\\n    YearnFinanceWrapper YIELD_PROVIDER;\\n    uint128 MIN_RATE;\\n    uint128 MAX_RATE;\\n    uint128 RATE_SPACING;\\n    uint128 MAX_BORROWABLE_AMOUNT;\\n    uint128 LOAN_DURATION;\\n    uint128 LIQUIDITY_REWARDS_DISTRIBUTION_RATE;\\n    uint128 COOLDOWN_PERIOD;\\n    uint128 REPAYMENT_PERIOD;\\n    uint128 LATE_REPAY_FEE_PER_BOND_RATE;\\n    uint128 ESTABLISHMENT_FEE_RATE;\\n    uint128 REPAYMENT_FEE_RATE;\\n    uint128 LIQUIDITY_REWARDS_ACTIVATION_THRESHOLD;\\n    bool EARLY_REPAY;\\n  }\\n\\n  struct PoolState {\\n    bool active;\\n    bool defaulted;\\n    bool closed;\\n    uint128 currentMaturity;\\n    uint128 bondsIssuedQuantity;\\n    uint128 normalizedBorrowedAmount;\\n    uint128 normalizedAvailableDeposits;\\n    uint128 lowerInterestRate;\\n    uint128 nextLoanMinStart;\\n    uint128 remainingAdjustedLiquidityRewardsReserve;\\n    uint128 yieldProviderLiquidityRatio;\\n    uint128 currentBondsIssuanceIndex;\\n    uint128 defaultTimestamp;\\n  }\\n\\n  struct Pool {\\n    PoolParameters parameters;\\n    PoolState state;\\n    mapping(uint256 => Tick) ticks;\\n  }\\n}\\n\",\"keccak256\":\"0xdbc63bb06cd1a767bff6359d14c639789988acf871336c5842d6e1a5dd2b1968\",\"license\":\"AGPL-3.0\"},\"src/lib/Uint128WadRayMath.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity >=0.8.0 <=0.8.13;\\n\\nimport \\\"./WadRayMath.sol\\\";\\n\\n/**\\n * @title Uint128WadRayMath library\\n **/\\nlibrary Uint128WadRayMath {\\n  using WadRayMath for uint256;\\n\\n  /**\\n   * @dev Multiplies a wad to a ray, making back and forth conversions\\n   * @param a Wad\\n   * @param b Ray\\n   * @return The result of a*b, in wad\\n   **/\\n  function wadRayMul(uint128 a, uint128 b) internal pure returns (uint128) {\\n    return uint128(uint256(a).wadToRay().rayMul(uint256(b)).rayToWad());\\n  }\\n\\n  /**\\n   * @dev Divides a wad to a ray, making back and forth conversions\\n   * @param a Wad\\n   * @param b Ray\\n   * @return The result of a/b, in wad\\n   **/\\n  function wadRayDiv(uint128 a, uint128 b) internal pure returns (uint128) {\\n    return uint128(uint256(a).wadToRay().rayDiv(uint256(b)).rayToWad());\\n  }\\n\\n  /**\\n   * @dev Divides two ray, rounding half up to the nearest ray\\n   * @param a Ray\\n   * @param b Ray\\n   * @return The result of a/b, in ray\\n   **/\\n  function rayDiv(uint128 a, uint128 b) internal pure returns (uint128) {\\n    return uint128(uint256(a).rayDiv(uint256(b)));\\n  }\\n\\n  /**\\n   * @dev Multiplies two wad, rounding half up to the nearest wad\\n   * @param a Wad\\n   * @param b Wad\\n   * @return The result of a*b, in wad\\n   **/\\n  function wadMul(uint128 a, uint128 b) internal pure returns (uint128) {\\n    return uint128(uint256(a).wadMul(uint256(b)));\\n  }\\n\\n  /**\\n   * @dev Divides two wad, rounding half up to the nearest wad\\n   * @param a Wad\\n   * @param b Wad\\n   * @return The result of a/b, in wad\\n   **/\\n  function wadDiv(uint128 a, uint128 b) internal pure returns (uint128) {\\n    return uint128(uint256(a).wadDiv(uint256(b)));\\n  }\\n\\n  /**\\n   * @dev Converts wad up to ray\\n   * @param a Wad\\n   * @return a converted in ray\\n   **/\\n  function wadToRay(uint128 a) internal pure returns (uint128) {\\n    return uint128(uint256(a).wadToRay());\\n  }\\n}\\n\",\"keccak256\":\"0x2137b74ce30a60655a32b0c8ebdde4834477e70c5c02c2cfc450a5a7e9f9797d\",\"license\":\"AGPL-3.0\"},\"src/lib/WadRayMath.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity >=0.8.0 <=0.8.13;\\n\\nimport \\\"./Errors.sol\\\";\\n\\n/**\\n * @title WadRayMath library\\n * @author Aave\\n * @dev Provides mul and div function for wads (decimal numbers with 18 digits precision) and rays (decimals with 27 digits)\\n **/\\n\\nlibrary WadRayMath {\\n  uint256 internal constant WAD = 1e18;\\n  uint256 internal constant halfWAD = WAD / 2;\\n\\n  uint256 internal constant RAY = 1e27;\\n  uint256 internal constant halfRAY = RAY / 2;\\n\\n  uint256 internal constant WAD_RAY_RATIO = 1e9;\\n\\n  /**\\n   * @return One ray, 1e27\\n   **/\\n  function ray() internal pure returns (uint256) {\\n    return RAY;\\n  }\\n\\n  /**\\n   * @return One wad, 1e18\\n   **/\\n  function wad() internal pure returns (uint256) {\\n    return WAD;\\n  }\\n\\n  /**\\n   * @return Half ray, 1e27/2\\n   **/\\n  function halfRay() internal pure returns (uint256) {\\n    return halfRAY;\\n  }\\n\\n  /**\\n   * @return Half ray, 1e18/2\\n   **/\\n  function halfWad() internal pure returns (uint256) {\\n    return halfWAD;\\n  }\\n\\n  /**\\n   * @dev Multiplies two wad, rounding half up to the nearest wad\\n   * @param a Wad\\n   * @param b Wad\\n   * @return The result of a*b, in wad\\n   **/\\n  function wadMul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    if (a == 0 || b == 0) {\\n      return 0;\\n    }\\n\\n    if (a > (type(uint256).max - halfWAD) / b) {\\n      revert Errors.MATH_MULTIPLICATION_OVERFLOW();\\n    }\\n\\n    return (a * b + halfWAD) / WAD;\\n  }\\n\\n  /**\\n   * @dev Divides two wad, rounding half up to the nearest wad\\n   * @param a Wad\\n   * @param b Wad\\n   * @return The result of a/b, in wad\\n   **/\\n  function wadDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n    if (b == 0) {\\n      revert Errors.MATH_DIVISION_BY_ZERO();\\n    }\\n    uint256 halfB = b / 2;\\n\\n    if (a > (type(uint256).max - halfB) / WAD) {\\n      revert Errors.MATH_MULTIPLICATION_OVERFLOW();\\n    }\\n\\n    return (a * WAD + halfB) / b;\\n  }\\n\\n  /**\\n   * @dev Multiplies two ray, rounding half up to the nearest ray\\n   * @param a Ray\\n   * @param b Ray\\n   * @return The result of a*b, in ray\\n   **/\\n  function rayMul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    if (a == 0 || b == 0) {\\n      return 0;\\n    }\\n\\n    if (a > (type(uint256).max - halfRAY) / b) {\\n      revert Errors.MATH_MULTIPLICATION_OVERFLOW();\\n    }\\n\\n    return (a * b + halfRAY) / RAY;\\n  }\\n\\n  /**\\n   * @dev Divides two ray, rounding half up to the nearest ray\\n   * @param a Ray\\n   * @param b Ray\\n   * @return The result of a/b, in ray\\n   **/\\n  function rayDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n    if (b == 0) {\\n      revert Errors.MATH_DIVISION_BY_ZERO();\\n    }\\n    uint256 halfB = b / 2;\\n\\n    if (a > (type(uint256).max - halfB) / RAY) {\\n      revert Errors.MATH_MULTIPLICATION_OVERFLOW();\\n    }\\n\\n    return (a * RAY + halfB) / b;\\n  }\\n\\n  /**\\n   * @dev Casts ray down to wad\\n   * @param a Ray\\n   * @return a casted to wad, rounded half up to the nearest wad\\n   **/\\n  function rayToWad(uint256 a) internal pure returns (uint256) {\\n    uint256 halfRatio = WAD_RAY_RATIO / 2;\\n    uint256 result = halfRatio + a;\\n    if (result < halfRatio) {\\n      revert Errors.MATH_ADDITION_OVERFLOW();\\n    }\\n\\n    return result / WAD_RAY_RATIO;\\n  }\\n\\n  /**\\n   * @dev Converts wad up to ray\\n   * @param a Wad\\n   * @return a converted in ray\\n   **/\\n  function wadToRay(uint256 a) internal pure returns (uint256) {\\n    uint256 result = a * WAD_RAY_RATIO;\\n    if (result / WAD_RAY_RATIO != a) {\\n      revert Errors.MATH_MULTIPLICATION_OVERFLOW();\\n    }\\n    return result;\\n  }\\n}\\n\",\"keccak256\":\"0x3d8a18991b8247bb42657dbbcb266d30b345b666748f7a3eddb96f59336fb845\",\"license\":\"AGPL-3.0\"}},\"version\":1}",
  "bytecode": "0x612e7661003a600b82828239805160001a60731461002d57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600436106101365760003560e01c80636ef48f57116100b757806398bc050e1161007b57806398bc050e146102d4578063ca8701f3146102f4578063d393d8c814610314578063e6a69ab814610334578063ec733dc81461033f57600080fd5b80636ef48f57146102685780637177b97a1461028857806374e636341461029b578063839a9c29146102ae57806387610e26146102c157600080fd5b8063552033c4116100fe578063552033c4146101f15780635953c226146102115780635ccb5f2f146102245780636839a261146102375780636a1460241461025957600080fd5b8063163e99251461013b5780631aceb8a31461017357806339a594321461019e5780633d29c209146101be5780634de6e915146101d1575b600080fd5b61014e6101493660046129a1565b61035f565b604080516001600160801b039384168152929091166020830152015b60405180910390f35b6101866101813660046129a1565b6104c5565b6040516001600160801b03909116815260200161016a565b8180156101aa57600080fd5b5061014e6101b93660046129a1565b61058f565b61014e6101cc3660046129dd565b61089d565b8180156101dd57600080fd5b5061014e6101ec3660046129a1565b610a6b565b610203676765c793fa10079d601b1b81565b60405190815260200161016a565b61018661021f3660046129dd565b610c20565b610186610232366004612a2a565b610c82565b81801561024357600080fd5b50610257610252366004612a56565b610cc0565b005b610203670de0b6b3a764000081565b81801561027457600080fd5b506101866102833660046129dd565b610db5565b610186610296366004612a2a565b611209565b6101866102a9366004612a89565b61135f565b6101866102bc366004612ab3565b6113fe565b6101866102cf366004612ae3565b6114f1565b8180156102e057600080fd5b5061014e6102ef3660046129a1565b61153c565b81801561030057600080fd5b5061025761030f3660046129dd565b6116f9565b81801561032057600080fd5b5061018661032f366004612a2a565b611975565b6102036301e1338081565b81801561034b57600080fd5b5061018661035a366004612a89565b611a48565b6001600160801b03808316600090815260108501602052604081206004810154600282015492938493868216926103a29291821691600160801b90910416611c3f565b6001600160801b0316106103b85783915061044e565b6005810154600482015460028301546001600160801b0380881693600160801b908190048216936103ef9383169291900416611c3f565b6103f99190612b23565b6001600160801b03161061040f5783915061044e565b6005810154600482015460028301546001600160801b03600160801b9384900481169361044193928216920416611c3f565b61044b9190612b23565b91505b600a8601546000906104a4908790630100000090046001600160801b03161561049157600a8901546102cf904290630100000090046001600160801b0316612b4e565b60058901546001600160801b03166114f1565b90506104b96001600160801b03841682611c6e565b93505050935093915050565b600a830154600090630100000090046001600160801b0316421161052457600a84015461051d9061050d9084906102cf904290630100000090046001600160801b0316612b76565b6001600160801b03851690611c86565b9050610588565b600f8401546001600160801b0342811691161561054b5750600f8401546001600160801b03165b600a850154610584906105749085906102cf90630100000090046001600160801b031685612b76565b6001600160801b03861690611c6e565b9150505b9392505050565b6001600160801b0382166000908152601084016020526040812081906105b58686611c9e565b600a860154630100000090046001600160801b0316156106935760058101546105ea906001600160801b038681169116611d52565b600382018054919450849160009061060c9084906001600160801b0316612b23565b82546101009290920a6001600160801b03818102199093169183160217909155600e8801546106459250600160801b9004166001612b23565b86546040519193507f6b32953a10c12f4f709f00322897857fe00fa2b561933e0455a84ec2b988394a91610686916001600160a01b03169088908790612b8d565b60405180910390a161083a565b60048101546001600160801b03600160801b9091048116906106b790861682611d52565b9350838260010160108282829054906101000a90046001600160801b03166106df9190612b23565b92506101000a8154816001600160801b0302191690836001600160801b03160217905550838260020160008282829054906101000a90046001600160801b03166107299190612b23565b82546101009290920a6001600160801b03818102199093169183160217909155600e890154600c8a018054600160801b909204831696508893509160009161077391859116612b23565b92506101000a8154816001600160801b0302191690836001600160801b031602179055506107d96107c98789600a0160040160109054906101000a90046001600160801b03168a611d7c9092919063ffffffff16565b6001600160801b03861690611d52565b875460048401546040519296507feb939464eaf5658e2bd584955706dfc8718bc675077d094a211b8cac0dc0211992610830926001600160a01b0316918a918991600160801b90046001600160801b031690612bb7565b60405180910390a1505b600c860154600160801b90046001600160801b031615806108725750600c8601546001600160801b03600160801b9091048116908616105b1561089457600c860180546001600160801b03808816600160801b0291161790555b50935093915050565b6001600160801b0380841660009081526010860160205260408120600e87015491928392600160801b9004811690851611156108e0576000859250925050610a62565b6108fe6108ee888887611d7c565b6001600160801b03871690611c3f565b6001820154909550600090600160801b90046001600160801b03161561099b57600282015460018301546109989161094d916001600160801b03600160801b9283900481169290910416612b23565b6002840154600185015461098991610979916001600160801b0391821691600160801b90910416612b4e565b6001600160801b038a1690611c86565b6001600160801b031690611c6e565b90505b806001600160801b0316866001600160801b031610610a3257600282015460018301546001600160801b03918216600160801b9091049091161115610a215760028201546001830154610a1e91610a06916001600160801b0391821691600160801b90910416612b4e565b6001840154610989906001600160801b031684611c86565b93505b610a2b8187612b4e565b9250610a5f565b6001820154610a58906001600160801b03600160801b8204811691610989911689611c86565b9350600092505b50505b94509492505050565b6001600160801b03808316600090815260108501602052604081206001810154919283921615610894576001810154610aaf9087906001600160801b0316876104c5565b9250610ac46001600160801b03851684611c86565b6003820154909250600090610ae990600160801b90046001600160801b031685612b4e565b9050610b45610b378360010160109054906101000a90046001600160801b031685848660050160109054906101000a90046001600160801b0316610b2d9190612b23565b6109899190612b23565b6001600160801b0316611dc9565b600483018054601090610b69908490600160801b90046001600160801b0316612b23565b82546101009290920a6001600160801b038181021990931691831602179091556001840180546001600160801b031916908190556003850180548316905560058501805483169055600160801b908190048216600286018190558a5460048701546040517fff35c143d5dc744162bac187e3560816b62bc72c20ec53e36395daef9e03e44d9650610c0e956001600160a01b03909316948d9493920490911690612bb7565b60405180910390a15050935093915050565b6001600160801b0380841660009081526010860160205260408120600281015491929091168203610c55576000915050610c7a565b6002810154610c76906001600160801b039081169061098990861687611c86565b9150505b949350505050565b6008820154600b830154600091610588916001600160801b0391821691610cb191600160801b90041685612b4e565b6001600160801b031690611c86565b60018301546001600160a01b03811690600090610cf1906001600160801b03851690600160a01b900460ff16611ddd565b60028601549091506001600160a01b0390811690610d1b908416826001600160801b038516611e10565b610d396001600160a01b03841686306001600160801b038616611efb565b60405163b6b55f2560e01b81526001600160801b03831660048201526001600160a01b0382169063b6b55f25906024016020604051808303816000875af1158015610d88573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610dac9190612be9565b50505050505050565b6001600160801b03831660009081526010850160205260408120610dd98686611c9e565b600e8601546001600160801b03600160801b909104811690841611611043576000610e05878787611f33565b9050808260050160108282829054906101000a90046001600160801b0316610e2d9190612b4e565b92506101000a8154816001600160801b0302191690836001600160801b03160217905550848260010160108282829054906101000a90046001600160801b0316610e779190612b4e565b92506101000a8154816001600160801b0302191690836001600160801b03160217905550848260020160008282829054906101000a90046001600160801b0316610ec19190612b4e565b92506101000a8154816001600160801b0302191690836001600160801b0316021790555080610f198360040160109054906101000a90046001600160801b0316876001600160801b0316611c3f90919063ffffffff16565b610f239190612b23565b9250610f37836001600160801b0316611f76565b600c88018054600090610f549084906001600160801b0316612b4e565b82546101009290920a6001600160801b03818102199093169183160217909155600184015416159050610fcc57848260020160108282829054906101000a90046001600160801b0316610fa79190612b23565b92506101000a8154816001600160801b0302191690836001600160801b031602179055505b86546004830154604080516001600160a01b0390931683526001600160801b03898116602085015288811684830152600160801b909204821660608401529083166080830152517f1730e9224e5c01521101f332272398652a257d5d98db66bba89c1ec90f1bffed9181900360a00190a1506110e1565b6003810180548591906000906110639084906001600160801b0316612b4e565b82546101009290920a6001600160801b03818102199093169183160217909155600583015461109792508682169116611c3f565b86546040519193507f13251a991ec2ae0985d69e3040c4494fc01b6d47783d144eefcc8c704e90d448916110d8916001600160a01b03169088908890612b8d565b60405180910390a15b600c8601546001600160801b03868116600160801b9092041614801561111957506001810154600160801b90046001600160801b0316155b15611200576004860154600090611139906001600160801b031687612b23565b90505b60038701546001600160801b03600160801b90910481169082161180159061118857506001600160801b038082166000908152601089016020526040902060010154600160801b900416155b156111ac5760048701546111a5906001600160801b031682612b23565b905061113c565b60038701546001600160801b03600160801b9091048116908216106111e157600c870180546001600160801b031690556111fe565b600c870180546001600160801b03808416600160801b0291161790555b505b50949350505050565b60018201546000908190611231906001600160801b03851690600160a01b900460ff16611f8f565b6007850154909150600090611259906001600160801b0380851691600160801b900416611c86565b6004860154600c870154919450849250839160009161128c916001600160801b0391821691600160801b90910416612b4e565b90505b6000826001600160801b03161180156112bf575060038701546001600160801b03600160801b9091048116908216105b156113555760048701546112dc906001600160801b031682612b23565b6001600160801b03808216600090815260108a01602052604090206002015491925016156113505760008061131289848661035f565b90925090506113218185612b4e565b93506113416113318460006114f1565b6001600160801b03841690611c86565b61134b9088612b23565b965050505b61128f565b5050505092915050565b6006810154600a8201546000918291611392916001600160801b03600160801b9091048116916301000000900416612b23565b6001600160801b03169050804211156113f857600f8301546000906001600160801b03166113c057426113cf565b600f8401546001600160801b03165b60078501549091506001600160801b03166113ea8383612b76565b6113f49190612c02565b9250505b50919050565b600a820154600090630100000090046001600160801b03168103611424575060006114eb565b8161145857600a830154630100000090046001600160801b031642116114585750600b8201546001600160801b03166114eb565b600c830154600160801b90046001600160801b03165b60038401546001600160801b03600160801b9091048116908216116114e9576001600160801b0380821660009081526010860160205260409020600181015490916114bc91879116846104c5565b6114c69084612b23565b60048601549093506114e291506001600160801b031682612b23565b905061146e565b505b92915050565b60006105886301e133806115116001600160801b03808616908716612c02565b61151b9190612c37565b61152d90670de0b6b3a7640000612c4b565b670de0b6b3a764000090611c6e565b6001600160801b038083166000908152601085016020526040812060048101546002820154929384938682169261157f9291821691600160801b90910416611c3f565b6001600160801b0316106115955783915061044e565b6005810154600482015460028301546001600160801b0380881693600160801b908190048216936115cc9383169291900416611c3f565b6115d69190612b23565b6001600160801b031610611666576004810154600282015485935061160f916001600160801b0391821691600160801b90910416611c3f565b6116199085612b4e565b60058201805460109061163d908490600160801b90046001600160801b0316612b4e565b92506101000a8154816001600160801b0302191690836001600160801b0316021790555061044e565b6005810154600482015460028301546001600160801b03600160801b9384900481169361169893928216920416611c3f565b6116a29190612b23565b6005820180546001600160801b031690559150600a8601546000906104a49087906001600160801b036301000000909104161561049157600a8901546102cf904290630100000090046001600160801b0316612b4e565b6001600160801b038084166000908152601086016020526040812060018101805491938693919261172c91859116612b23565b92506101000a8154816001600160801b0302191690836001600160801b0316021790555060006117858260040160109054906101000a90046001600160801b0316846001600160801b0316611d5290919063ffffffff16565b60028301549091506001600160801b0390811690821611156117b1575060028101546001600160801b03165b6002820180548291906000906117d19084906001600160801b0316612b4e565b92506101000a8154816001600160801b0302191690836001600160801b03160217905550828260030160108282829054906101000a90046001600160801b031661181b9190612b23565b82546101009290920a6001600160801b03818102199093169183160217909155600184015460028501546000935061185e9290811691600160801b900416611c6e565b87546004850154604080516001600160a01b0390931683526001600160801b038a81166020850152868116848301528881166060850152600160801b9092048216608084015290831660a0830152519192507fc60ea0182cc3972769ae86644c38db9bfeb957d141f01b27ff56b35b5097dda5919081900360c00190a1600b870180548691906000906118fb9084906001600160801b0316612b23565b92506101000a8154816001600160801b0302191690836001600160801b031602179055508387600a0160020160008282829054906101000a90046001600160801b03166119489190612b4e565b92506101000a8154816001600160801b0302191690836001600160801b0316021790555050505050505050565b6002820154604080516325b0985360e21b815290516000926001600160a01b0316916396c2614c9160048083019260209291908290030181865afa1580156119c1573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906119e59190612be9565b90506119fa6001600160801b03831682611d52565b600d84018054601090611a1e908490600160801b90046001600160801b0316612b23565b92506101000a8154816001600160801b0302191690836001600160801b0316021790555092915050565b600c8101546002820154604080516325b0985360e21b81529051600093600160801b90046001600160801b03169284926001600160a01b03909116916396c2614c916004808201926020929091908290030181865afa158015611aaf573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ad39190612be9565b600d850154909150611af590600160801b90046001600160801b031682611c3f565b600c850180549194508491600090611b179084906001600160801b0316612b23565b82546101009290920a6001600160801b03818102199093169183160217909155600d860180549091169055505b6001600160801b0380831660009081526010860160205260409020600101541615801590611b8a575060038401546001600160801b03600160801b909104811690831611155b15611c3857600b8401546001600160801b038381166000908152601087016020526040902060010154611bc892821691610989918782169116611c86565b6001600160801b0380841660009081526010808801602052604090912060050180549092611c00918591600160801b90910416612b23565b82546101009290920a6001600160801b038181021990931691831602179091556004860154611c3192501683612b23565b9150611b44565b5050919050565b6000610588611c69836001600160801b0316611c63866001600160801b0316611fb7565b90611ff6565b612087565b60006105886001600160801b038481169084166120d8565b60006105886001600160801b03848116908416612170565b6002820154604080516325b0985360e21b815290516000926001600160a01b0316916396c2614c9160048083019260209291908290030181865afa158015611cea573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611d0e9190612be9565b9050611d1b8383836121e7565b6001600160801b039182166000908152601090930160205260409092206005018054919092166001600160801b0319909116179055565b6000610588611c69836001600160801b0316611d76866001600160801b0316611fb7565b9061242a565b6001600160801b03808316600090815260108501602090815260408083208585168452918290528220549092169190829003611dc157676765c793fa10079d601b1b91505b509392505050565b60006114eb826001600160801b0316611fb7565b6000670de0b6b3a7640000611df383600a612d47565b611e06906001600160801b038616612c02565b6105889190612c37565b604051636eb1769f60e11b81523060048201526001600160a01b038381166024830152600091839186169063dd62ed3e90604401602060405180830381865afa158015611e61573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611e859190612be9565b611e8f9190612c4b565b6040516001600160a01b038516602482015260448101829052909150611ef590859063095ea7b360e01b906064015b60408051601f198184030181529190526020810180516001600160e01b03166001600160e01b0319909316929092179091526124b4565b50505050565b6040516001600160a01b0380851660248301528316604482015260648101829052611ef59085906323b872dd60e01b90608401611ebe565b6001600160801b03808316600090815260108501602052604081206002810154600582015492939192610584929182169161098991600160801b90041686611c86565b60006103e8611f858184612d53565b6114eb9190612d79565b6000611f9c82600a612d47565b611e06670de0b6b3a76400006001600160801b038616612c02565b600080611fc8633b9aca0084612c02565b905082611fd9633b9aca0083612c37565b146114eb5760405162a748d160e21b815260040160405180910390fd5b6000821580612003575081155b15612010575060006114eb565b816120276002676765c793fa10079d601b1b612c37565b61203390600019612b76565b61203d9190612c37565b83111561205c5760405162a748d160e21b815260040160405180910390fd5b676765c793fa10079d601b1b612073600282612c37565b61207d8486612c02565b611e069190612c4b565b6000806120996002633b9aca00612c37565b905060006120a78483612c4b565b9050818110156120ca576040516307af724160e11b815260040160405180910390fd5b6113f4633b9aca0082612c37565b6000816000036120fb576040516308693c7b60e31b815260040160405180910390fd5b6000612108600284612c37565b9050670de0b6b3a764000061211f82600019612b76565b6121299190612c37565b8411156121485760405162a748d160e21b815260040160405180910390fd5b828161215c670de0b6b3a764000087612c02565b6121669190612c4b565b610c7a9190612c37565b600082158061217d575081155b1561218a575060006114eb565b8161219e6002670de0b6b3a7640000612c37565b6121aa90600019612b76565b6121b49190612c37565b8311156121d35760405162a748d160e21b815260040160405180910390fd5b670de0b6b3a7640000612073600282612c37565b6001600160801b0380831660009081526010850160205260409020600481015490914291161015611ef5576000808080612222888888612590565b9296509094509250905061223f6001600160801b03831687611d52565b600d89018054601090612263908490600160801b90046001600160801b0316612b4e565b82546101009290920a6001600160801b03818102199093169183160217909155600287015461229492501682611c3f565b61229e9083612b23565b600c890180546000906122bb9084906001600160801b0316612b23565b92506101000a8154816001600160801b0302191690836001600160801b0316021790555060008560050160109054906101000a90046001600160801b0316846123049190612b4e565b6004870154909150600160801b90046001600160801b0316600003612389576005860180546001600160801b0319166001600160801b03891617905588546040517f6f0af1abcf1ba2094b30510b922c357e153645953c99cedcd9c731cf49c0e49191612380916001600160a01b03909116908b908b90612b8d565b60405180910390a15b6005860180546001600160801b03908116600160801b8783168102919091179092556001600160801b03198782168302164282161760048901558a54600d8c01547f22f7e29f1509fbd47f3e61026d7920c0dd79fd86b88861a8e5f0f7d130a584e3936001600160a01b03909216928c926124069204168b611c3f565b846040516124179493929190612bb7565b60405180910390a1505050505050505050565b60008160000361244d576040516308693c7b60e31b815260040160405180910390fd5b600061245a600284612c37565b9050676765c793fa10079d601b1b61247482600019612b76565b61247e9190612c37565b84111561249d5760405162a748d160e21b815260040160405180910390fd5b828161215c676765c793fa10079d601b1b87612c02565b6000612509826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b03166127409092919063ffffffff16565b80519091501561258b57808060200190518101906125279190612da8565b61258b5760405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e6044820152691bdd081cdd58d8d9595960b21b60648201526084015b60405180910390fd5b505050565b6001600160801b0380831660009081526010850160205260408120600481015491928392839283929091600160801b90041682036125dc57856000806000945094509450945050612737565b60048101546005820154600e8a01546001600160801b03600160801b938490048116985092820483169650600092918216911611156126295750600e8801546001600160801b0316612639565b5060058101546001600160801b03165b6126438188612b4e565b925061264f898961274f565b600d8a015490945060009061267490600160801b90046001600160801b031689611c3f565b9050806001600160801b0316856001600160801b03161115612694578094505b600a8a0154630100000090046001600160801b0316600003612702576126ba8488612b23565b60028401549097506001600160801b0316156126fd5760028301546126f0906001600160801b0390811690610989908816611dc9565b6126fa9088612b23565b96505b612733565b6002830154859061271c906001600160801b031686611c3f565b6127269190612b23565b6127309087612b23565b95505b5050505b93509350935093565b6060610c7a848460008561281b565b6001600160801b0380821660009081526010840160205260408120600c8501549192909116156114e957600c84015460048201546002830154610c7a926001600160801b0390811692610989926127b19290811691600160801b900416611c3f565b6004880154600b890154610cb1916001600160801b03600160801b91829004811692610989926127e49291041683612b4e565b60048901546127fc906001600160801b031642612b4e565b60058d0154610cb19190600160801b90046001600160801b0316612d79565b60608247101561287c5760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f6044820152651c8818d85b1b60d21b6064820152608401612582565b6001600160a01b0385163b6128d35760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e74726163740000006044820152606401612582565b600080866001600160a01b031685876040516128ef9190612df1565b60006040518083038185875af1925050503d806000811461292c576040519150601f19603f3d011682016040523d82523d6000602084013e612931565b606091505b509150915061294182828661294c565b979650505050505050565b6060831561295b575081610588565b82511561296b5782518084602001fd5b8160405162461bcd60e51b81526004016125829190612e0d565b80356001600160801b038116811461299c57600080fd5b919050565b6000806000606084860312156129b657600080fd5b833592506129c660208501612985565b91506129d460408501612985565b90509250925092565b600080600080608085870312156129f357600080fd5b84359350612a0360208601612985565b9250612a1160408601612985565b9150612a1f60608601612985565b905092959194509250565b60008060408385031215612a3d57600080fd5b82359150612a4d60208401612985565b90509250929050565b600080600060608486031215612a6b57600080fd5b8335925060208401356001600160a01b03811681146129c657600080fd5b600060208284031215612a9b57600080fd5b5035919050565b8015158114612ab057600080fd5b50565b60008060408385031215612ac657600080fd5b823591506020830135612ad881612aa2565b809150509250929050565b60008060408385031215612af657600080fd5b612aff83612985565b9150612a4d60208401612985565b634e487b7160e01b600052601160045260246000fd5b60006001600160801b03828116848216808303821115612b4557612b45612b0d565b01949350505050565b60006001600160801b0383811690831681811015612b6e57612b6e612b0d565b039392505050565b600082821015612b8857612b88612b0d565b500390565b6001600160a01b039390931683526001600160801b03918216602084015216604082015260600190565b6001600160a01b039490941684526001600160801b039283166020850152908216604084015216606082015260800190565b600060208284031215612bfb57600080fd5b5051919050565b6000816000190483118215151615612c1c57612c1c612b0d565b500290565b634e487b7160e01b600052601260045260246000fd5b600082612c4657612c46612c21565b500490565b60008219821115612c5e57612c5e612b0d565b500190565b600181815b80851115612c9e578160001904821115612c8457612c84612b0d565b80851615612c9157918102915b93841c9390800290612c68565b509250929050565b600082612cb5575060016114eb565b81612cc2575060006114eb565b8160018114612cd85760028114612ce257612cfe565b60019150506114eb565b60ff841115612cf357612cf3612b0d565b50506001821b6114eb565b5060208310610133831016604e8410600b8410161715612d21575081810a6114eb565b612d2b8383612c63565b8060001904821115612d3f57612d3f612b0d565b029392505050565b60006105888383612ca6565b60006001600160801b0383811680612d6d57612d6d612c21565b92169190910492915050565b60006001600160801b0382811684821681151582840482111615612d9f57612d9f612b0d565b02949350505050565b600060208284031215612dba57600080fd5b815161058881612aa2565b60005b83811015612de0578181015183820152602001612dc8565b83811115611ef55750506000910152565b60008251612e03818460208701612dc5565b9190910192915050565b6020815260008251806020840152612e2c816040850160208701612dc5565b601f01601f1916919091016040019291505056fea2646970667358221220727417d395c9d1125656277695bd67393b1c1866ed0b544d9938dd99daee50f764736f6c634300080d0033",
  "deployedBytecode": "0x73000000000000000000000000000000000000000030146080604052600436106101365760003560e01c80636ef48f57116100b757806398bc050e1161007b57806398bc050e146102d4578063ca8701f3146102f4578063d393d8c814610314578063e6a69ab814610334578063ec733dc81461033f57600080fd5b80636ef48f57146102685780637177b97a1461028857806374e636341461029b578063839a9c29146102ae57806387610e26146102c157600080fd5b8063552033c4116100fe578063552033c4146101f15780635953c226146102115780635ccb5f2f146102245780636839a261146102375780636a1460241461025957600080fd5b8063163e99251461013b5780631aceb8a31461017357806339a594321461019e5780633d29c209146101be5780634de6e915146101d1575b600080fd5b61014e6101493660046129a1565b61035f565b604080516001600160801b039384168152929091166020830152015b60405180910390f35b6101866101813660046129a1565b6104c5565b6040516001600160801b03909116815260200161016a565b8180156101aa57600080fd5b5061014e6101b93660046129a1565b61058f565b61014e6101cc3660046129dd565b61089d565b8180156101dd57600080fd5b5061014e6101ec3660046129a1565b610a6b565b610203676765c793fa10079d601b1b81565b60405190815260200161016a565b61018661021f3660046129dd565b610c20565b610186610232366004612a2a565b610c82565b81801561024357600080fd5b50610257610252366004612a56565b610cc0565b005b610203670de0b6b3a764000081565b81801561027457600080fd5b506101866102833660046129dd565b610db5565b610186610296366004612a2a565b611209565b6101866102a9366004612a89565b61135f565b6101866102bc366004612ab3565b6113fe565b6101866102cf366004612ae3565b6114f1565b8180156102e057600080fd5b5061014e6102ef3660046129a1565b61153c565b81801561030057600080fd5b5061025761030f3660046129dd565b6116f9565b81801561032057600080fd5b5061018661032f366004612a2a565b611975565b6102036301e1338081565b81801561034b57600080fd5b5061018661035a366004612a89565b611a48565b6001600160801b03808316600090815260108501602052604081206004810154600282015492938493868216926103a29291821691600160801b90910416611c3f565b6001600160801b0316106103b85783915061044e565b6005810154600482015460028301546001600160801b0380881693600160801b908190048216936103ef9383169291900416611c3f565b6103f99190612b23565b6001600160801b03161061040f5783915061044e565b6005810154600482015460028301546001600160801b03600160801b9384900481169361044193928216920416611c3f565b61044b9190612b23565b91505b600a8601546000906104a4908790630100000090046001600160801b03161561049157600a8901546102cf904290630100000090046001600160801b0316612b4e565b60058901546001600160801b03166114f1565b90506104b96001600160801b03841682611c6e565b93505050935093915050565b600a830154600090630100000090046001600160801b0316421161052457600a84015461051d9061050d9084906102cf904290630100000090046001600160801b0316612b76565b6001600160801b03851690611c86565b9050610588565b600f8401546001600160801b0342811691161561054b5750600f8401546001600160801b03165b600a850154610584906105749085906102cf90630100000090046001600160801b031685612b76565b6001600160801b03861690611c6e565b9150505b9392505050565b6001600160801b0382166000908152601084016020526040812081906105b58686611c9e565b600a860154630100000090046001600160801b0316156106935760058101546105ea906001600160801b038681169116611d52565b600382018054919450849160009061060c9084906001600160801b0316612b23565b82546101009290920a6001600160801b03818102199093169183160217909155600e8801546106459250600160801b9004166001612b23565b86546040519193507f6b32953a10c12f4f709f00322897857fe00fa2b561933e0455a84ec2b988394a91610686916001600160a01b03169088908790612b8d565b60405180910390a161083a565b60048101546001600160801b03600160801b9091048116906106b790861682611d52565b9350838260010160108282829054906101000a90046001600160801b03166106df9190612b23565b92506101000a8154816001600160801b0302191690836001600160801b03160217905550838260020160008282829054906101000a90046001600160801b03166107299190612b23565b82546101009290920a6001600160801b03818102199093169183160217909155600e890154600c8a018054600160801b909204831696508893509160009161077391859116612b23565b92506101000a8154816001600160801b0302191690836001600160801b031602179055506107d96107c98789600a0160040160109054906101000a90046001600160801b03168a611d7c9092919063ffffffff16565b6001600160801b03861690611d52565b875460048401546040519296507feb939464eaf5658e2bd584955706dfc8718bc675077d094a211b8cac0dc0211992610830926001600160a01b0316918a918991600160801b90046001600160801b031690612bb7565b60405180910390a1505b600c860154600160801b90046001600160801b031615806108725750600c8601546001600160801b03600160801b9091048116908616105b1561089457600c860180546001600160801b03808816600160801b0291161790555b50935093915050565b6001600160801b0380841660009081526010860160205260408120600e87015491928392600160801b9004811690851611156108e0576000859250925050610a62565b6108fe6108ee888887611d7c565b6001600160801b03871690611c3f565b6001820154909550600090600160801b90046001600160801b03161561099b57600282015460018301546109989161094d916001600160801b03600160801b9283900481169290910416612b23565b6002840154600185015461098991610979916001600160801b0391821691600160801b90910416612b4e565b6001600160801b038a1690611c86565b6001600160801b031690611c6e565b90505b806001600160801b0316866001600160801b031610610a3257600282015460018301546001600160801b03918216600160801b9091049091161115610a215760028201546001830154610a1e91610a06916001600160801b0391821691600160801b90910416612b4e565b6001840154610989906001600160801b031684611c86565b93505b610a2b8187612b4e565b9250610a5f565b6001820154610a58906001600160801b03600160801b8204811691610989911689611c86565b9350600092505b50505b94509492505050565b6001600160801b03808316600090815260108501602052604081206001810154919283921615610894576001810154610aaf9087906001600160801b0316876104c5565b9250610ac46001600160801b03851684611c86565b6003820154909250600090610ae990600160801b90046001600160801b031685612b4e565b9050610b45610b378360010160109054906101000a90046001600160801b031685848660050160109054906101000a90046001600160801b0316610b2d9190612b23565b6109899190612b23565b6001600160801b0316611dc9565b600483018054601090610b69908490600160801b90046001600160801b0316612b23565b82546101009290920a6001600160801b038181021990931691831602179091556001840180546001600160801b031916908190556003850180548316905560058501805483169055600160801b908190048216600286018190558a5460048701546040517fff35c143d5dc744162bac187e3560816b62bc72c20ec53e36395daef9e03e44d9650610c0e956001600160a01b03909316948d9493920490911690612bb7565b60405180910390a15050935093915050565b6001600160801b0380841660009081526010860160205260408120600281015491929091168203610c55576000915050610c7a565b6002810154610c76906001600160801b039081169061098990861687611c86565b9150505b949350505050565b6008820154600b830154600091610588916001600160801b0391821691610cb191600160801b90041685612b4e565b6001600160801b031690611c86565b60018301546001600160a01b03811690600090610cf1906001600160801b03851690600160a01b900460ff16611ddd565b60028601549091506001600160a01b0390811690610d1b908416826001600160801b038516611e10565b610d396001600160a01b03841686306001600160801b038616611efb565b60405163b6b55f2560e01b81526001600160801b03831660048201526001600160a01b0382169063b6b55f25906024016020604051808303816000875af1158015610d88573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610dac9190612be9565b50505050505050565b6001600160801b03831660009081526010850160205260408120610dd98686611c9e565b600e8601546001600160801b03600160801b909104811690841611611043576000610e05878787611f33565b9050808260050160108282829054906101000a90046001600160801b0316610e2d9190612b4e565b92506101000a8154816001600160801b0302191690836001600160801b03160217905550848260010160108282829054906101000a90046001600160801b0316610e779190612b4e565b92506101000a8154816001600160801b0302191690836001600160801b03160217905550848260020160008282829054906101000a90046001600160801b0316610ec19190612b4e565b92506101000a8154816001600160801b0302191690836001600160801b0316021790555080610f198360040160109054906101000a90046001600160801b0316876001600160801b0316611c3f90919063ffffffff16565b610f239190612b23565b9250610f37836001600160801b0316611f76565b600c88018054600090610f549084906001600160801b0316612b4e565b82546101009290920a6001600160801b03818102199093169183160217909155600184015416159050610fcc57848260020160108282829054906101000a90046001600160801b0316610fa79190612b23565b92506101000a8154816001600160801b0302191690836001600160801b031602179055505b86546004830154604080516001600160a01b0390931683526001600160801b03898116602085015288811684830152600160801b909204821660608401529083166080830152517f1730e9224e5c01521101f332272398652a257d5d98db66bba89c1ec90f1bffed9181900360a00190a1506110e1565b6003810180548591906000906110639084906001600160801b0316612b4e565b82546101009290920a6001600160801b03818102199093169183160217909155600583015461109792508682169116611c3f565b86546040519193507f13251a991ec2ae0985d69e3040c4494fc01b6d47783d144eefcc8c704e90d448916110d8916001600160a01b03169088908890612b8d565b60405180910390a15b600c8601546001600160801b03868116600160801b9092041614801561111957506001810154600160801b90046001600160801b0316155b15611200576004860154600090611139906001600160801b031687612b23565b90505b60038701546001600160801b03600160801b90910481169082161180159061118857506001600160801b038082166000908152601089016020526040902060010154600160801b900416155b156111ac5760048701546111a5906001600160801b031682612b23565b905061113c565b60038701546001600160801b03600160801b9091048116908216106111e157600c870180546001600160801b031690556111fe565b600c870180546001600160801b03808416600160801b0291161790555b505b50949350505050565b60018201546000908190611231906001600160801b03851690600160a01b900460ff16611f8f565b6007850154909150600090611259906001600160801b0380851691600160801b900416611c86565b6004860154600c870154919450849250839160009161128c916001600160801b0391821691600160801b90910416612b4e565b90505b6000826001600160801b03161180156112bf575060038701546001600160801b03600160801b9091048116908216105b156113555760048701546112dc906001600160801b031682612b23565b6001600160801b03808216600090815260108a01602052604090206002015491925016156113505760008061131289848661035f565b90925090506113218185612b4e565b93506113416113318460006114f1565b6001600160801b03841690611c86565b61134b9088612b23565b965050505b61128f565b5050505092915050565b6006810154600a8201546000918291611392916001600160801b03600160801b9091048116916301000000900416612b23565b6001600160801b03169050804211156113f857600f8301546000906001600160801b03166113c057426113cf565b600f8401546001600160801b03165b60078501549091506001600160801b03166113ea8383612b76565b6113f49190612c02565b9250505b50919050565b600a820154600090630100000090046001600160801b03168103611424575060006114eb565b8161145857600a830154630100000090046001600160801b031642116114585750600b8201546001600160801b03166114eb565b600c830154600160801b90046001600160801b03165b60038401546001600160801b03600160801b9091048116908216116114e9576001600160801b0380821660009081526010860160205260409020600181015490916114bc91879116846104c5565b6114c69084612b23565b60048601549093506114e291506001600160801b031682612b23565b905061146e565b505b92915050565b60006105886301e133806115116001600160801b03808616908716612c02565b61151b9190612c37565b61152d90670de0b6b3a7640000612c4b565b670de0b6b3a764000090611c6e565b6001600160801b038083166000908152601085016020526040812060048101546002820154929384938682169261157f9291821691600160801b90910416611c3f565b6001600160801b0316106115955783915061044e565b6005810154600482015460028301546001600160801b0380881693600160801b908190048216936115cc9383169291900416611c3f565b6115d69190612b23565b6001600160801b031610611666576004810154600282015485935061160f916001600160801b0391821691600160801b90910416611c3f565b6116199085612b4e565b60058201805460109061163d908490600160801b90046001600160801b0316612b4e565b92506101000a8154816001600160801b0302191690836001600160801b0316021790555061044e565b6005810154600482015460028301546001600160801b03600160801b9384900481169361169893928216920416611c3f565b6116a29190612b23565b6005820180546001600160801b031690559150600a8601546000906104a49087906001600160801b036301000000909104161561049157600a8901546102cf904290630100000090046001600160801b0316612b4e565b6001600160801b038084166000908152601086016020526040812060018101805491938693919261172c91859116612b23565b92506101000a8154816001600160801b0302191690836001600160801b0316021790555060006117858260040160109054906101000a90046001600160801b0316846001600160801b0316611d5290919063ffffffff16565b60028301549091506001600160801b0390811690821611156117b1575060028101546001600160801b03165b6002820180548291906000906117d19084906001600160801b0316612b4e565b92506101000a8154816001600160801b0302191690836001600160801b03160217905550828260030160108282829054906101000a90046001600160801b031661181b9190612b23565b82546101009290920a6001600160801b03818102199093169183160217909155600184015460028501546000935061185e9290811691600160801b900416611c6e565b87546004850154604080516001600160a01b0390931683526001600160801b038a81166020850152868116848301528881166060850152600160801b9092048216608084015290831660a0830152519192507fc60ea0182cc3972769ae86644c38db9bfeb957d141f01b27ff56b35b5097dda5919081900360c00190a1600b870180548691906000906118fb9084906001600160801b0316612b23565b92506101000a8154816001600160801b0302191690836001600160801b031602179055508387600a0160020160008282829054906101000a90046001600160801b03166119489190612b4e565b92506101000a8154816001600160801b0302191690836001600160801b0316021790555050505050505050565b6002820154604080516325b0985360e21b815290516000926001600160a01b0316916396c2614c9160048083019260209291908290030181865afa1580156119c1573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906119e59190612be9565b90506119fa6001600160801b03831682611d52565b600d84018054601090611a1e908490600160801b90046001600160801b0316612b23565b92506101000a8154816001600160801b0302191690836001600160801b0316021790555092915050565b600c8101546002820154604080516325b0985360e21b81529051600093600160801b90046001600160801b03169284926001600160a01b03909116916396c2614c916004808201926020929091908290030181865afa158015611aaf573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ad39190612be9565b600d850154909150611af590600160801b90046001600160801b031682611c3f565b600c850180549194508491600090611b179084906001600160801b0316612b23565b82546101009290920a6001600160801b03818102199093169183160217909155600d860180549091169055505b6001600160801b0380831660009081526010860160205260409020600101541615801590611b8a575060038401546001600160801b03600160801b909104811690831611155b15611c3857600b8401546001600160801b038381166000908152601087016020526040902060010154611bc892821691610989918782169116611c86565b6001600160801b0380841660009081526010808801602052604090912060050180549092611c00918591600160801b90910416612b23565b82546101009290920a6001600160801b038181021990931691831602179091556004860154611c3192501683612b23565b9150611b44565b5050919050565b6000610588611c69836001600160801b0316611c63866001600160801b0316611fb7565b90611ff6565b612087565b60006105886001600160801b038481169084166120d8565b60006105886001600160801b03848116908416612170565b6002820154604080516325b0985360e21b815290516000926001600160a01b0316916396c2614c9160048083019260209291908290030181865afa158015611cea573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611d0e9190612be9565b9050611d1b8383836121e7565b6001600160801b039182166000908152601090930160205260409092206005018054919092166001600160801b0319909116179055565b6000610588611c69836001600160801b0316611d76866001600160801b0316611fb7565b9061242a565b6001600160801b03808316600090815260108501602090815260408083208585168452918290528220549092169190829003611dc157676765c793fa10079d601b1b91505b509392505050565b60006114eb826001600160801b0316611fb7565b6000670de0b6b3a7640000611df383600a612d47565b611e06906001600160801b038616612c02565b6105889190612c37565b604051636eb1769f60e11b81523060048201526001600160a01b038381166024830152600091839186169063dd62ed3e90604401602060405180830381865afa158015611e61573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611e859190612be9565b611e8f9190612c4b565b6040516001600160a01b038516602482015260448101829052909150611ef590859063095ea7b360e01b906064015b60408051601f198184030181529190526020810180516001600160e01b03166001600160e01b0319909316929092179091526124b4565b50505050565b6040516001600160a01b0380851660248301528316604482015260648101829052611ef59085906323b872dd60e01b90608401611ebe565b6001600160801b03808316600090815260108501602052604081206002810154600582015492939192610584929182169161098991600160801b90041686611c86565b60006103e8611f858184612d53565b6114eb9190612d79565b6000611f9c82600a612d47565b611e06670de0b6b3a76400006001600160801b038616612c02565b600080611fc8633b9aca0084612c02565b905082611fd9633b9aca0083612c37565b146114eb5760405162a748d160e21b815260040160405180910390fd5b6000821580612003575081155b15612010575060006114eb565b816120276002676765c793fa10079d601b1b612c37565b61203390600019612b76565b61203d9190612c37565b83111561205c5760405162a748d160e21b815260040160405180910390fd5b676765c793fa10079d601b1b612073600282612c37565b61207d8486612c02565b611e069190612c4b565b6000806120996002633b9aca00612c37565b905060006120a78483612c4b565b9050818110156120ca576040516307af724160e11b815260040160405180910390fd5b6113f4633b9aca0082612c37565b6000816000036120fb576040516308693c7b60e31b815260040160405180910390fd5b6000612108600284612c37565b9050670de0b6b3a764000061211f82600019612b76565b6121299190612c37565b8411156121485760405162a748d160e21b815260040160405180910390fd5b828161215c670de0b6b3a764000087612c02565b6121669190612c4b565b610c7a9190612c37565b600082158061217d575081155b1561218a575060006114eb565b8161219e6002670de0b6b3a7640000612c37565b6121aa90600019612b76565b6121b49190612c37565b8311156121d35760405162a748d160e21b815260040160405180910390fd5b670de0b6b3a7640000612073600282612c37565b6001600160801b0380831660009081526010850160205260409020600481015490914291161015611ef5576000808080612222888888612590565b9296509094509250905061223f6001600160801b03831687611d52565b600d89018054601090612263908490600160801b90046001600160801b0316612b4e565b82546101009290920a6001600160801b03818102199093169183160217909155600287015461229492501682611c3f565b61229e9083612b23565b600c890180546000906122bb9084906001600160801b0316612b23565b92506101000a8154816001600160801b0302191690836001600160801b0316021790555060008560050160109054906101000a90046001600160801b0316846123049190612b4e565b6004870154909150600160801b90046001600160801b0316600003612389576005860180546001600160801b0319166001600160801b03891617905588546040517f6f0af1abcf1ba2094b30510b922c357e153645953c99cedcd9c731cf49c0e49191612380916001600160a01b03909116908b908b90612b8d565b60405180910390a15b6005860180546001600160801b03908116600160801b8783168102919091179092556001600160801b03198782168302164282161760048901558a54600d8c01547f22f7e29f1509fbd47f3e61026d7920c0dd79fd86b88861a8e5f0f7d130a584e3936001600160a01b03909216928c926124069204168b611c3f565b846040516124179493929190612bb7565b60405180910390a1505050505050505050565b60008160000361244d576040516308693c7b60e31b815260040160405180910390fd5b600061245a600284612c37565b9050676765c793fa10079d601b1b61247482600019612b76565b61247e9190612c37565b84111561249d5760405162a748d160e21b815260040160405180910390fd5b828161215c676765c793fa10079d601b1b87612c02565b6000612509826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b03166127409092919063ffffffff16565b80519091501561258b57808060200190518101906125279190612da8565b61258b5760405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e6044820152691bdd081cdd58d8d9595960b21b60648201526084015b60405180910390fd5b505050565b6001600160801b0380831660009081526010850160205260408120600481015491928392839283929091600160801b90041682036125dc57856000806000945094509450945050612737565b60048101546005820154600e8a01546001600160801b03600160801b938490048116985092820483169650600092918216911611156126295750600e8801546001600160801b0316612639565b5060058101546001600160801b03165b6126438188612b4e565b925061264f898961274f565b600d8a015490945060009061267490600160801b90046001600160801b031689611c3f565b9050806001600160801b0316856001600160801b03161115612694578094505b600a8a0154630100000090046001600160801b0316600003612702576126ba8488612b23565b60028401549097506001600160801b0316156126fd5760028301546126f0906001600160801b0390811690610989908816611dc9565b6126fa9088612b23565b96505b612733565b6002830154859061271c906001600160801b031686611c3f565b6127269190612b23565b6127309087612b23565b95505b5050505b93509350935093565b6060610c7a848460008561281b565b6001600160801b0380821660009081526010840160205260408120600c8501549192909116156114e957600c84015460048201546002830154610c7a926001600160801b0390811692610989926127b19290811691600160801b900416611c3f565b6004880154600b890154610cb1916001600160801b03600160801b91829004811692610989926127e49291041683612b4e565b60048901546127fc906001600160801b031642612b4e565b60058d0154610cb19190600160801b90046001600160801b0316612d79565b60608247101561287c5760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f6044820152651c8818d85b1b60d21b6064820152608401612582565b6001600160a01b0385163b6128d35760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e74726163740000006044820152606401612582565b600080866001600160a01b031685876040516128ef9190612df1565b60006040518083038185875af1925050503d806000811461292c576040519150601f19603f3d011682016040523d82523d6000602084013e612931565b606091505b509150915061294182828661294c565b979650505050505050565b6060831561295b575081610588565b82511561296b5782518084602001fd5b8160405162461bcd60e51b81526004016125829190612e0d565b80356001600160801b038116811461299c57600080fd5b919050565b6000806000606084860312156129b657600080fd5b833592506129c660208501612985565b91506129d460408501612985565b90509250925092565b600080600080608085870312156129f357600080fd5b84359350612a0360208601612985565b9250612a1160408601612985565b9150612a1f60608601612985565b905092959194509250565b60008060408385031215612a3d57600080fd5b82359150612a4d60208401612985565b90509250929050565b600080600060608486031215612a6b57600080fd5b8335925060208401356001600160a01b03811681146129c657600080fd5b600060208284031215612a9b57600080fd5b5035919050565b8015158114612ab057600080fd5b50565b60008060408385031215612ac657600080fd5b823591506020830135612ad881612aa2565b809150509250929050565b60008060408385031215612af657600080fd5b612aff83612985565b9150612a4d60208401612985565b634e487b7160e01b600052601160045260246000fd5b60006001600160801b03828116848216808303821115612b4557612b45612b0d565b01949350505050565b60006001600160801b0383811690831681811015612b6e57612b6e612b0d565b039392505050565b600082821015612b8857612b88612b0d565b500390565b6001600160a01b039390931683526001600160801b03918216602084015216604082015260600190565b6001600160a01b039490941684526001600160801b039283166020850152908216604084015216606082015260800190565b600060208284031215612bfb57600080fd5b5051919050565b6000816000190483118215151615612c1c57612c1c612b0d565b500290565b634e487b7160e01b600052601260045260246000fd5b600082612c4657612c46612c21565b500490565b60008219821115612c5e57612c5e612b0d565b500190565b600181815b80851115612c9e578160001904821115612c8457612c84612b0d565b80851615612c9157918102915b93841c9390800290612c68565b509250929050565b600082612cb5575060016114eb565b81612cc2575060006114eb565b8160018114612cd85760028114612ce257612cfe565b60019150506114eb565b60ff841115612cf357612cf3612b0d565b50506001821b6114eb565b5060208310610133831016604e8410600b8410161715612d21575081810a6114eb565b612d2b8383612c63565b8060001904821115612d3f57612d3f612b0d565b029392505050565b60006105888383612ca6565b60006001600160801b0383811680612d6d57612d6d612c21565b92169190910492915050565b60006001600160801b0382811684821681151582840482111615612d9f57612d9f612b0d565b02949350505050565b600060208284031215612dba57600080fd5b815161058881612aa2565b60005b83811015612de0578181015183820152602001612dc8565b83811115611ef55750506000910152565b60008251612e03818460208701612dc5565b9190910192915050565b6020815260008251806020840152612e2c816040850160208701612dc5565b601f01601f1916919091016040019291505056fea2646970667358221220727417d395c9d1125656277695bd67393b1c1866ed0b544d9938dd99daee50f764736f6c634300080d0033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "_getRepaymentAmount(Types.Pool storage,uint128)": {
        "params": {
          "loanAmount": "The total amount of the loan"
        },
        "returns": {
          "repaymentAmount": "The total amount to be repaid *"
        }
      },
      "addBondsToTick(Types.Pool storage,uint128,uint128,uint128)": {
        "details": "Makes all the state changes necessary to add bonds to a tick Updates tick data and conversion data*"
      },
      "calculateBondIssuanceForTick(Types.Pool storage,uint128,uint128)": {
        "details": "Computes the quantity of bonds that would be purchased.*"
      },
      "computeAmountRepartitionForTick(Types.Pool storage,uint128,uint128,uint128)": {
        "details": "Computes how the position is split between deposit and bonds*"
      },
      "depositToTick(Types.Pool storage,uint128,uint128)": {
        "details": "Deposit to a target tick Updates tick data*"
      },
      "distributeLiquidityRewards(Types.Pool storage)": {
        "details": "Distributes remaining liquidity rewards reserve to lenders Called in case of pool default*"
      },
      "getBondsIssuanceParametersForTick(Types.Pool storage,uint128,uint128)": {
        "details": "Computes the quantity of bonds purchased, and the equivalent adjusted deposit amount used for the issuance*"
      },
      "getRepayValue(Types.Pool storage,bool)": {
        "details": "The return value includes only notional and accrued interest, it does not include any fees due for repay by the borrrower*"
      },
      "getTickBondPrice(uint128,uint128)": {
        "params": {
          "loanDuration": "The duration of the loan",
          "rate": "The rate of the loan"
        },
        "returns": {
          "price": "The price per bond*"
        }
      },
      "peekAccruedFeesShare(Types.Pool storage,uint128,uint128,uint128)": {
        "details": "Get share of accumulated fees from estimated current tick state*"
      },
      "repayForTick(Types.Pool storage,uint128,uint128)": {
        "details": "Updates tick data after a repayment*"
      },
      "topUpLiquidityRewards(Types.Pool storage,uint128)": {
        "details": "Top up liquidity rewards for later distribution*"
      },
      "withdrawDepositedAmountForTick(Types.Pool storage,uint128,uint128,uint128)": {
        "details": "Updates tick data after a withdrawal consisting of only amount deposited to yield provider*"
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "_getRepaymentAmount(Types.Pool storage,uint128)": {
        "notice": "Get repaymentAmount for a given loanAmount"
      },
      "getTickBondPrice(uint128,uint128)": {
        "notice": "Calculates the proce per bond accordingly to rate and loanDuration "
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}